<!doctype html><html lang=ja dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Houdini Workflowについて | FX HACK</title><meta name=keywords content="Houdini,Python,Workflow"><meta name=description content="いままで何回もHoudini Workflowをつくってきたので、どんなことをやっているか紹介したいと思います。
小規模な会社にいるからとか個人でやってるから、そんなの必要ないと考える人もいるかもしれませんが、そうは思いません。数人の会社で働いたことがありますが、確実にワークフローが少しでもないと良いパフォーマンスを出すことをできません。
大規模な会社には専任のTDがいてパイプラインがしっかりあり、色々便利なこともあります。反面、大きくなりすぎた会社ほど、やる気のない人や老害がたまり自由度がなくなり最新の流れにもついていけなくなったり、ワークフローを作るのに大工事したり、パイプラインにも手をいれなければいけないみたいなことも起こってしまいます。小規模だとパイプラインを作るのは難しいですが、ワークフローは自分たちの好きに作りやすいです。自分たちにあったものを構築できれば、小回りがきいて大きな所に負けないワークフローを構築しアドバンテージにすることも出来ます。
ワークフローは、TDの人やスクリプトをかける人が作るものだと考えるでしょうが、実際に作業するアーティスト主導で構築するべきです。なぜならそのワークフローを使うのは作業者であり、なにが必要なのかを知ってるのは作業者であるアーティストだからです。
パイプライン？　ワークフロー？ そもそもパイプラインとワークフローの違いはなんなんでしょうか？
パイプラインは、別部署へのデータを送る時、たとえばアセットデータやアニメーションデータやレンダーイメージのパブリッシュなど です。決められた場所かつ安全な場所にパブリッシュしたり、決まったフォーマットに変換したりします。また、ファイルの命名規則やチェック方法やShotgunとの連携もこちらの役割です。
ワークフローは、アーティストがショット作業をする時に必要なルール・ツール を用意しておくことです。
パイプラインはTDが担当しますが、ワークフローは出来る限りそのツールや流れを熟知した人が作るのに携わるのが良いと思います。そしてFXはPythonは書けて当たり前なので、TDにお前らどうせ自分たちで出来るからとか言われ、他の部署を先にやってからと後回しにされがちです。
目的 まずは何のためにワークフローを作るかの目的をしかっり決めましょう。
私はいつもアーティストが絵作りだけに集中できる環境を作ることを目的にし、できるかぎりのことをするようにしています。
何を基準にツールやルールを作るかというと、基本この２つをベースに考えます。
ヒューマンエラーをなくす 毎回同じことをしたくない 代表格は、キャッシュやレンダーの出力先を毎回入力することです。これはもはや人間のやることではありません。
チームで新しくワークフローを作る場合は、みんなの意見を聞いて不便なことや要望を洗い出してあげることも大事です。
チームにジュニアレベルの人やHoudiniに詳しくない人がいるとしたら、色んなレベルの人にもスムーズにいくルールを考える必要があるかもしれません。
環境変数 まずプロジェクト固有の変数について考えましょう。変数は、プロジェクト全体に適用されるグローバル変数と、シーケンスやショットごとに値が変わるローカル変数にわけられます。 プロジェクト名やシーケンス名を定義しとくとフォルダの移動やアウトプット先を決めるのが楽になります。ただこの変数はパイプラインとして設定されてることが多いです。小規模な会社や個人では自身で設定してもいいと思います。これらを設定することによってどういうことが出来るかはあとで説明します。
PROJ = 'BurningProj' 他のソフトからAlembic等でデータを持ってきた時、シーンスケールを正しくしてあげる必要があります。なぜなら、Houdiniのシミュレーション系ノードのデフォルト値は、1Grid=1mを前提として値が設定されています。これにあわせてやるのが一番良いです。
大抵の場合はインポートしたものを0.1倍か0.01倍すればいいでしょうが、海外のクライアントからもらったデータはメートルでなくインチで作業してる場合があります。その場合は39.37で割る必要があります。覚えたくないですよね。なので、コレも変数にしておきましょう。
SCALE_FACTOR = 10 他には、レンダーサイズも変数にしてもいいかもしれません。
RENDER_RES_X=1920 RENDER_RES_Y=960 また、WinodwsやLinuxのプラットフォームが混在してる場合、マウントするところを変数にしたとき、少し便利になります。どいうことかというとWindowsはZ:/proj/BuringProjがLinuxでは/proj/BuringProjの場合、$PROJ_ROOT/BuringProjという書き方に統一できます。協力会社によってはクライアントと同じドライブレターが使えないときは、協力会社に$PROJ_ROOTをX:/good_client/A_Inc/projみたいに設定してもらえれば、フォルダ構造を維持したままシーンファイルを渡せば、別の環境でもシーンを容易に再現できる可能性が高まります。
PROJ_ROOT = 'Z:/proj' 日本でもNetflixの仕事が増えてきたせいか、やっとColorMangementが浸透してきましたね。Houdiniも他のソフト同様、OCIOの環境変数を設定してあげる必要があります。ACTIVE_VIEWSはなくてもいいです。VFXではシーケンスやショットごとでLutが違う場合があるので、OCIO_ACTIVE_VIEWSを変動出来るようにしてもいいかと思います。
OCIO='/proj/BurninigProj/tools/OCIO/will_be_beautiful.ocio' OCIO_ACTIVE_VIEWS='Rec.709' ローカル変数の代表は、シーケンスとショット番号、フレームレンジとかでしょうか。
SEQ = 'seq_01' SHOT = 'shot_003' P_START = 1001 P_END = 1032 さて、これらをどうやって全員に行き渡せるかですが、大きい会社ならランチャーがあると思うので、そこで設定してもいいです。
小さい会社や個人の場合は、パッケージを使うといいでしょう。 https://www.sidefx.com/ja/docs/houdini/ref/plugins.html
たとえば/proj/BurningProj/tools/houdiniというフォルダの中にプロジェクトのHDAやスクリプトを置き変数を定義するとします。
/proj/BurningProj └── tools └── houdini └── otls └── packages └── scripts └── toolbar └── maya └── nuke まずメインのパッケージを作ります。これをpackagesフォルダのBurningProj."><meta name=author content="Shohei Okazaki"><link rel=canonical href=https://ShoheiOkazaki.github.io/FXHACK/posts/2021-04-29/><link crossorigin=anonymous href=/FXHACK/assets/css/stylesheet.bdde7bb857ad3abdf871caf8647f6e680d60ed2394aa4300d0a169da82d4b137.css integrity="sha256-vd57uFetOr34ccr4ZH9uaA1g7SOUqkMA0KFp2oLUsTc=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/FXHACK/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ShoheiOkazaki.github.io/FXHACK/Thinking_Face_Emoji_large.png><link rel=icon type=image/png sizes=16x16 href=https://ShoheiOkazaki.github.io/FXHACK/Thinking_Face_Emoji_large.png><link rel=icon type=image/png sizes=32x32 href=https://ShoheiOkazaki.github.io/FXHACK/Thinking_Face_Emoji_large.png><link rel=apple-touch-icon href=https://ShoheiOkazaki.github.io/FXHACK/Thinking_Face_Emoji_large.png><link rel=mask-icon href=https://ShoheiOkazaki.github.io/FXHACK/Thinking_Face_Emoji_large.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://ShoheiOkazaki.github.io/FXHACK/posts/2021-04-29/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Houdini Workflowについて"><meta property="og:description" content="いままで何回もHoudini Workflowをつくってきたので、どんなことをやっているか紹介したいと思います。
小規模な会社にいるからとか個人でやってるから、そんなの必要ないと考える人もいるかもしれませんが、そうは思いません。数人の会社で働いたことがありますが、確実にワークフローが少しでもないと良いパフォーマンスを出すことをできません。
大規模な会社には専任のTDがいてパイプラインがしっかりあり、色々便利なこともあります。反面、大きくなりすぎた会社ほど、やる気のない人や老害がたまり自由度がなくなり最新の流れにもついていけなくなったり、ワークフローを作るのに大工事したり、パイプラインにも手をいれなければいけないみたいなことも起こってしまいます。小規模だとパイプラインを作るのは難しいですが、ワークフローは自分たちの好きに作りやすいです。自分たちにあったものを構築できれば、小回りがきいて大きな所に負けないワークフローを構築しアドバンテージにすることも出来ます。
ワークフローは、TDの人やスクリプトをかける人が作るものだと考えるでしょうが、実際に作業するアーティスト主導で構築するべきです。なぜならそのワークフローを使うのは作業者であり、なにが必要なのかを知ってるのは作業者であるアーティストだからです。
パイプライン？　ワークフロー？ そもそもパイプラインとワークフローの違いはなんなんでしょうか？
パイプラインは、別部署へのデータを送る時、たとえばアセットデータやアニメーションデータやレンダーイメージのパブリッシュなど です。決められた場所かつ安全な場所にパブリッシュしたり、決まったフォーマットに変換したりします。また、ファイルの命名規則やチェック方法やShotgunとの連携もこちらの役割です。
ワークフローは、アーティストがショット作業をする時に必要なルール・ツール を用意しておくことです。
パイプラインはTDが担当しますが、ワークフローは出来る限りそのツールや流れを熟知した人が作るのに携わるのが良いと思います。そしてFXはPythonは書けて当たり前なので、TDにお前らどうせ自分たちで出来るからとか言われ、他の部署を先にやってからと後回しにされがちです。
目的 まずは何のためにワークフローを作るかの目的をしかっり決めましょう。
私はいつもアーティストが絵作りだけに集中できる環境を作ることを目的にし、できるかぎりのことをするようにしています。
何を基準にツールやルールを作るかというと、基本この２つをベースに考えます。
ヒューマンエラーをなくす 毎回同じことをしたくない 代表格は、キャッシュやレンダーの出力先を毎回入力することです。これはもはや人間のやることではありません。
チームで新しくワークフローを作る場合は、みんなの意見を聞いて不便なことや要望を洗い出してあげることも大事です。
チームにジュニアレベルの人やHoudiniに詳しくない人がいるとしたら、色んなレベルの人にもスムーズにいくルールを考える必要があるかもしれません。
環境変数 まずプロジェクト固有の変数について考えましょう。変数は、プロジェクト全体に適用されるグローバル変数と、シーケンスやショットごとに値が変わるローカル変数にわけられます。 プロジェクト名やシーケンス名を定義しとくとフォルダの移動やアウトプット先を決めるのが楽になります。ただこの変数はパイプラインとして設定されてることが多いです。小規模な会社や個人では自身で設定してもいいと思います。これらを設定することによってどういうことが出来るかはあとで説明します。
PROJ = 'BurningProj' 他のソフトからAlembic等でデータを持ってきた時、シーンスケールを正しくしてあげる必要があります。なぜなら、Houdiniのシミュレーション系ノードのデフォルト値は、1Grid=1mを前提として値が設定されています。これにあわせてやるのが一番良いです。
大抵の場合はインポートしたものを0.1倍か0.01倍すればいいでしょうが、海外のクライアントからもらったデータはメートルでなくインチで作業してる場合があります。その場合は39.37で割る必要があります。覚えたくないですよね。なので、コレも変数にしておきましょう。
SCALE_FACTOR = 10 他には、レンダーサイズも変数にしてもいいかもしれません。
RENDER_RES_X=1920 RENDER_RES_Y=960 また、WinodwsやLinuxのプラットフォームが混在してる場合、マウントするところを変数にしたとき、少し便利になります。どいうことかというとWindowsはZ:/proj/BuringProjがLinuxでは/proj/BuringProjの場合、$PROJ_ROOT/BuringProjという書き方に統一できます。協力会社によってはクライアントと同じドライブレターが使えないときは、協力会社に$PROJ_ROOTをX:/good_client/A_Inc/projみたいに設定してもらえれば、フォルダ構造を維持したままシーンファイルを渡せば、別の環境でもシーンを容易に再現できる可能性が高まります。
PROJ_ROOT = 'Z:/proj' 日本でもNetflixの仕事が増えてきたせいか、やっとColorMangementが浸透してきましたね。Houdiniも他のソフト同様、OCIOの環境変数を設定してあげる必要があります。ACTIVE_VIEWSはなくてもいいです。VFXではシーケンスやショットごとでLutが違う場合があるので、OCIO_ACTIVE_VIEWSを変動出来るようにしてもいいかと思います。
OCIO='/proj/BurninigProj/tools/OCIO/will_be_beautiful.ocio' OCIO_ACTIVE_VIEWS='Rec.709' ローカル変数の代表は、シーケンスとショット番号、フレームレンジとかでしょうか。
SEQ = 'seq_01' SHOT = 'shot_003' P_START = 1001 P_END = 1032 さて、これらをどうやって全員に行き渡せるかですが、大きい会社ならランチャーがあると思うので、そこで設定してもいいです。
小さい会社や個人の場合は、パッケージを使うといいでしょう。 https://www.sidefx.com/ja/docs/houdini/ref/plugins.html
たとえば/proj/BurningProj/tools/houdiniというフォルダの中にプロジェクトのHDAやスクリプトを置き変数を定義するとします。
/proj/BurningProj └── tools └── houdini └── otls └── packages └── scripts └── toolbar └── maya └── nuke まずメインのパッケージを作ります。これをpackagesフォルダのBurningProj."><meta property="og:type" content="article"><meta property="og:url" content="https://ShoheiOkazaki.github.io/FXHACK/posts/2021-04-29/"><meta property="og:image" content="https://ShoheiOkazaki.github.io/FXHACK/profile.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-29T12:27:07+09:00"><meta property="article:modified_time" content="2021-04-29T12:27:07+09:00"><meta property="og:site_name" content="FX HACK"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ShoheiOkazaki.github.io/FXHACK/profile.jpg"><meta name=twitter:title content="Houdini Workflowについて"><meta name=twitter:description content="いままで何回もHoudini Workflowをつくってきたので、どんなことをやっているか紹介したいと思います。
小規模な会社にいるからとか個人でやってるから、そんなの必要ないと考える人もいるかもしれませんが、そうは思いません。数人の会社で働いたことがありますが、確実にワークフローが少しでもないと良いパフォーマンスを出すことをできません。
大規模な会社には専任のTDがいてパイプラインがしっかりあり、色々便利なこともあります。反面、大きくなりすぎた会社ほど、やる気のない人や老害がたまり自由度がなくなり最新の流れにもついていけなくなったり、ワークフローを作るのに大工事したり、パイプラインにも手をいれなければいけないみたいなことも起こってしまいます。小規模だとパイプラインを作るのは難しいですが、ワークフローは自分たちの好きに作りやすいです。自分たちにあったものを構築できれば、小回りがきいて大きな所に負けないワークフローを構築しアドバンテージにすることも出来ます。
ワークフローは、TDの人やスクリプトをかける人が作るものだと考えるでしょうが、実際に作業するアーティスト主導で構築するべきです。なぜならそのワークフローを使うのは作業者であり、なにが必要なのかを知ってるのは作業者であるアーティストだからです。
パイプライン？　ワークフロー？ そもそもパイプラインとワークフローの違いはなんなんでしょうか？
パイプラインは、別部署へのデータを送る時、たとえばアセットデータやアニメーションデータやレンダーイメージのパブリッシュなど です。決められた場所かつ安全な場所にパブリッシュしたり、決まったフォーマットに変換したりします。また、ファイルの命名規則やチェック方法やShotgunとの連携もこちらの役割です。
ワークフローは、アーティストがショット作業をする時に必要なルール・ツール を用意しておくことです。
パイプラインはTDが担当しますが、ワークフローは出来る限りそのツールや流れを熟知した人が作るのに携わるのが良いと思います。そしてFXはPythonは書けて当たり前なので、TDにお前らどうせ自分たちで出来るからとか言われ、他の部署を先にやってからと後回しにされがちです。
目的 まずは何のためにワークフローを作るかの目的をしかっり決めましょう。
私はいつもアーティストが絵作りだけに集中できる環境を作ることを目的にし、できるかぎりのことをするようにしています。
何を基準にツールやルールを作るかというと、基本この２つをベースに考えます。
ヒューマンエラーをなくす 毎回同じことをしたくない 代表格は、キャッシュやレンダーの出力先を毎回入力することです。これはもはや人間のやることではありません。
チームで新しくワークフローを作る場合は、みんなの意見を聞いて不便なことや要望を洗い出してあげることも大事です。
チームにジュニアレベルの人やHoudiniに詳しくない人がいるとしたら、色んなレベルの人にもスムーズにいくルールを考える必要があるかもしれません。
環境変数 まずプロジェクト固有の変数について考えましょう。変数は、プロジェクト全体に適用されるグローバル変数と、シーケンスやショットごとに値が変わるローカル変数にわけられます。 プロジェクト名やシーケンス名を定義しとくとフォルダの移動やアウトプット先を決めるのが楽になります。ただこの変数はパイプラインとして設定されてることが多いです。小規模な会社や個人では自身で設定してもいいと思います。これらを設定することによってどういうことが出来るかはあとで説明します。
PROJ = 'BurningProj' 他のソフトからAlembic等でデータを持ってきた時、シーンスケールを正しくしてあげる必要があります。なぜなら、Houdiniのシミュレーション系ノードのデフォルト値は、1Grid=1mを前提として値が設定されています。これにあわせてやるのが一番良いです。
大抵の場合はインポートしたものを0.1倍か0.01倍すればいいでしょうが、海外のクライアントからもらったデータはメートルでなくインチで作業してる場合があります。その場合は39.37で割る必要があります。覚えたくないですよね。なので、コレも変数にしておきましょう。
SCALE_FACTOR = 10 他には、レンダーサイズも変数にしてもいいかもしれません。
RENDER_RES_X=1920 RENDER_RES_Y=960 また、WinodwsやLinuxのプラットフォームが混在してる場合、マウントするところを変数にしたとき、少し便利になります。どいうことかというとWindowsはZ:/proj/BuringProjがLinuxでは/proj/BuringProjの場合、$PROJ_ROOT/BuringProjという書き方に統一できます。協力会社によってはクライアントと同じドライブレターが使えないときは、協力会社に$PROJ_ROOTをX:/good_client/A_Inc/projみたいに設定してもらえれば、フォルダ構造を維持したままシーンファイルを渡せば、別の環境でもシーンを容易に再現できる可能性が高まります。
PROJ_ROOT = 'Z:/proj' 日本でもNetflixの仕事が増えてきたせいか、やっとColorMangementが浸透してきましたね。Houdiniも他のソフト同様、OCIOの環境変数を設定してあげる必要があります。ACTIVE_VIEWSはなくてもいいです。VFXではシーケンスやショットごとでLutが違う場合があるので、OCIO_ACTIVE_VIEWSを変動出来るようにしてもいいかと思います。
OCIO='/proj/BurninigProj/tools/OCIO/will_be_beautiful.ocio' OCIO_ACTIVE_VIEWS='Rec.709' ローカル変数の代表は、シーケンスとショット番号、フレームレンジとかでしょうか。
SEQ = 'seq_01' SHOT = 'shot_003' P_START = 1001 P_END = 1032 さて、これらをどうやって全員に行き渡せるかですが、大きい会社ならランチャーがあると思うので、そこで設定してもいいです。
小さい会社や個人の場合は、パッケージを使うといいでしょう。 https://www.sidefx.com/ja/docs/houdini/ref/plugins.html
たとえば/proj/BurningProj/tools/houdiniというフォルダの中にプロジェクトのHDAやスクリプトを置き変数を定義するとします。
/proj/BurningProj └── tools └── houdini └── otls └── packages └── scripts └── toolbar └── maya └── nuke まずメインのパッケージを作ります。これをpackagesフォルダのBurningProj."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ShoheiOkazaki.github.io/FXHACK/posts/"},{"@type":"ListItem","position":2,"name":"Houdini Workflowについて","item":"https://ShoheiOkazaki.github.io/FXHACK/posts/2021-04-29/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Houdini Workflowについて","name":"Houdini Workflowについて","description":"いままで何回もHoudini Workflowをつくってきたので、どんなことをやっているか紹介したいと思います。\n小規模な会社にいるからとか個人でやってるから、そんなの必要ないと考える人もいるかもしれませんが、そうは思いません。数人の会社で働いたことがありますが、確実にワークフローが少しでもないと良いパフォーマンスを出すことをできません。\n大規模な会社には専任のTDがいてパイプラインがしっかりあり、色々便利なこともあります。反面、大きくなりすぎた会社ほど、やる気のない人や老害がたまり自由度がなくなり最新の流れにもついていけなくなったり、ワークフローを作るのに大工事したり、パイプラインにも手をいれなければいけないみたいなことも起こってしまいます。小規模だとパイプラインを作るのは難しいですが、ワークフローは自分たちの好きに作りやすいです。自分たちにあったものを構築できれば、小回りがきいて大きな所に負けないワークフローを構築しアドバンテージにすることも出来ます。\nワークフローは、TDの人やスクリプトをかける人が作るものだと考えるでしょうが、実際に作業するアーティスト主導で構築するべきです。なぜならそのワークフローを使うのは作業者であり、なにが必要なのかを知ってるのは作業者であるアーティストだからです。\nパイプライン？　ワークフロー？ そもそもパイプラインとワークフローの違いはなんなんでしょうか？\nパイプラインは、別部署へのデータを送る時、たとえばアセットデータやアニメーションデータやレンダーイメージのパブリッシュなど です。決められた場所かつ安全な場所にパブリッシュしたり、決まったフォーマットに変換したりします。また、ファイルの命名規則やチェック方法やShotgunとの連携もこちらの役割です。\nワークフローは、アーティストがショット作業をする時に必要なルール・ツール を用意しておくことです。\nパイプラインはTDが担当しますが、ワークフローは出来る限りそのツールや流れを熟知した人が作るのに携わるのが良いと思います。そしてFXはPythonは書けて当たり前なので、TDにお前らどうせ自分たちで出来るからとか言われ、他の部署を先にやってからと後回しにされがちです。\n目的 まずは何のためにワークフローを作るかの目的をしかっり決めましょう。\n私はいつもアーティストが絵作りだけに集中できる環境を作ることを目的にし、できるかぎりのことをするようにしています。\n何を基準にツールやルールを作るかというと、基本この２つをベースに考えます。\nヒューマンエラーをなくす 毎回同じことをしたくない 代表格は、キャッシュやレンダーの出力先を毎回入力することです。これはもはや人間のやることではありません。\nチームで新しくワークフローを作る場合は、みんなの意見を聞いて不便なことや要望を洗い出してあげることも大事です。\nチームにジュニアレベルの人やHoudiniに詳しくない人がいるとしたら、色んなレベルの人にもスムーズにいくルールを考える必要があるかもしれません。\n環境変数 まずプロジェクト固有の変数について考えましょう。変数は、\rプロジェクト全体に適用されるグローバル変数と、シーケンスやショットごとに値が変わるローカル変数にわけられます。 プロジェクト名やシーケンス名を定義しとくとフォルダの移動やアウトプット先を決めるのが楽になります。ただこの変数はパイプラインとして設定されてることが多いです。小規模な会社や個人では自身で設定してもいいと思います。これらを設定することによってどういうことが出来るかはあとで説明します。\nPROJ = \u0026#39;BurningProj\u0026#39; 他のソフトからAlembic等でデータを持ってきた時、シーンスケールを正しくしてあげる必要があります。なぜなら、Houdiniのシミュレーション系ノードのデフォルト値は、1Grid=1mを前提として値が設定されています。これにあわせてやるのが一番良いです。\n大抵の場合はインポートしたものを0.1倍か0.01倍すればいいでしょうが、海外のクライアントからもらったデータはメートルでなくインチで作業してる場合があります。その場合は39.37で割る必要があります。覚えたくないですよね。なので、コレも変数にしておきましょう。\nSCALE_FACTOR = 10 他には、レンダーサイズも変数にしてもいいかもしれません。\nRENDER_RES_X=1920 RENDER_RES_Y=960 また、WinodwsやLinuxのプラットフォームが混在してる場合、マウントするところを変数にしたとき、少し便利になります。どいうことかというとWindowsはZ:/proj/BuringProjがLinuxでは/proj/BuringProjの場合、$PROJ_ROOT/BuringProjという書き方に統一できます。協力会社によってはクライアントと同じドライブレターが使えないときは、協力会社に$PROJ_ROOTをX:/good_client/A_Inc/projみたいに設定してもらえれば、フォルダ構造を維持したままシーンファイルを渡せば、別の環境でもシーンを容易に再現できる可能性が高まります。\nPROJ_ROOT = \u0026#39;Z:/proj\u0026#39; 日本でもNetflixの仕事が増えてきたせいか、やっとColorMangementが浸透してきましたね。Houdiniも他のソフト同様、OCIOの環境変数を設定してあげる必要があります。ACTIVE_VIEWSはなくてもいいです。VFXではシーケンスやショットごとでLutが違う場合があるので、OCIO_ACTIVE_VIEWSを変動出来るようにしてもいいかと思います。\nOCIO=\u0026#39;/proj/BurninigProj/tools/OCIO/will_be_beautiful.ocio\u0026#39; OCIO_ACTIVE_VIEWS=\u0026#39;Rec.709\u0026#39; ローカル変数の代表は、シーケンスとショット番号、フレームレンジとかでしょうか。\nSEQ = \u0026#39;seq_01\u0026#39; SHOT = \u0026#39;shot_003\u0026#39; P_START = 1001 P_END = 1032 さて、これらをどうやって全員に行き渡せるかですが、大きい会社ならランチャーがあると思うので、そこで設定してもいいです。\n小さい会社や個人の場合は、パッケージを使うといいでしょう。 https://www.sidefx.com/ja/docs/houdini/ref/plugins.html\nたとえば/proj/BurningProj/tools/houdiniというフォルダの中にプロジェクトのHDAやスクリプトを置き変数を定義するとします。\n/proj/BurningProj └── tools └── houdini └── otls └── packages └── scripts └── toolbar └── maya └── nuke まずメインのパッケージを作ります。これをpackagesフォルダのBurningProj.","keywords":["Houdini","Python","Workflow"],"articleBody":"いままで何回もHoudini Workflowをつくってきたので、どんなことをやっているか紹介したいと思います。\n小規模な会社にいるからとか個人でやってるから、そんなの必要ないと考える人もいるかもしれませんが、そうは思いません。数人の会社で働いたことがありますが、確実にワークフローが少しでもないと良いパフォーマンスを出すことをできません。\n大規模な会社には専任のTDがいてパイプラインがしっかりあり、色々便利なこともあります。反面、大きくなりすぎた会社ほど、やる気のない人や老害がたまり自由度がなくなり最新の流れにもついていけなくなったり、ワークフローを作るのに大工事したり、パイプラインにも手をいれなければいけないみたいなことも起こってしまいます。小規模だとパイプラインを作るのは難しいですが、ワークフローは自分たちの好きに作りやすいです。自分たちにあったものを構築できれば、小回りがきいて大きな所に負けないワークフローを構築しアドバンテージにすることも出来ます。\nワークフローは、TDの人やスクリプトをかける人が作るものだと考えるでしょうが、実際に作業するアーティスト主導で構築するべきです。なぜならそのワークフローを使うのは作業者であり、なにが必要なのかを知ってるのは作業者であるアーティストだからです。\nパイプライン？　ワークフロー？ そもそもパイプラインとワークフローの違いはなんなんでしょうか？\nパイプラインは、別部署へのデータを送る時、たとえばアセットデータやアニメーションデータやレンダーイメージのパブリッシュなど です。決められた場所かつ安全な場所にパブリッシュしたり、決まったフォーマットに変換したりします。また、ファイルの命名規則やチェック方法やShotgunとの連携もこちらの役割です。\nワークフローは、アーティストがショット作業をする時に必要なルール・ツール を用意しておくことです。\nパイプラインはTDが担当しますが、ワークフローは出来る限りそのツールや流れを熟知した人が作るのに携わるのが良いと思います。そしてFXはPythonは書けて当たり前なので、TDにお前らどうせ自分たちで出来るからとか言われ、他の部署を先にやってからと後回しにされがちです。\n目的 まずは何のためにワークフローを作るかの目的をしかっり決めましょう。\n私はいつもアーティストが絵作りだけに集中できる環境を作ることを目的にし、できるかぎりのことをするようにしています。\n何を基準にツールやルールを作るかというと、基本この２つをベースに考えます。\nヒューマンエラーをなくす 毎回同じことをしたくない 代表格は、キャッシュやレンダーの出力先を毎回入力することです。これはもはや人間のやることではありません。\nチームで新しくワークフローを作る場合は、みんなの意見を聞いて不便なことや要望を洗い出してあげることも大事です。\nチームにジュニアレベルの人やHoudiniに詳しくない人がいるとしたら、色んなレベルの人にもスムーズにいくルールを考える必要があるかもしれません。\n環境変数 まずプロジェクト固有の変数について考えましょう。変数は、\rプロジェクト全体に適用されるグローバル変数と、シーケンスやショットごとに値が変わるローカル変数にわけられます。 プロジェクト名やシーケンス名を定義しとくとフォルダの移動やアウトプット先を決めるのが楽になります。ただこの変数はパイプラインとして設定されてることが多いです。小規模な会社や個人では自身で設定してもいいと思います。これらを設定することによってどういうことが出来るかはあとで説明します。\nPROJ = 'BurningProj' 他のソフトからAlembic等でデータを持ってきた時、シーンスケールを正しくしてあげる必要があります。なぜなら、Houdiniのシミュレーション系ノードのデフォルト値は、1Grid=1mを前提として値が設定されています。これにあわせてやるのが一番良いです。\n大抵の場合はインポートしたものを0.1倍か0.01倍すればいいでしょうが、海外のクライアントからもらったデータはメートルでなくインチで作業してる場合があります。その場合は39.37で割る必要があります。覚えたくないですよね。なので、コレも変数にしておきましょう。\nSCALE_FACTOR = 10 他には、レンダーサイズも変数にしてもいいかもしれません。\nRENDER_RES_X=1920 RENDER_RES_Y=960 また、WinodwsやLinuxのプラットフォームが混在してる場合、マウントするところを変数にしたとき、少し便利になります。どいうことかというとWindowsはZ:/proj/BuringProjがLinuxでは/proj/BuringProjの場合、$PROJ_ROOT/BuringProjという書き方に統一できます。協力会社によってはクライアントと同じドライブレターが使えないときは、協力会社に$PROJ_ROOTをX:/good_client/A_Inc/projみたいに設定してもらえれば、フォルダ構造を維持したままシーンファイルを渡せば、別の環境でもシーンを容易に再現できる可能性が高まります。\nPROJ_ROOT = 'Z:/proj' 日本でもNetflixの仕事が増えてきたせいか、やっとColorMangementが浸透してきましたね。Houdiniも他のソフト同様、OCIOの環境変数を設定してあげる必要があります。ACTIVE_VIEWSはなくてもいいです。VFXではシーケンスやショットごとでLutが違う場合があるので、OCIO_ACTIVE_VIEWSを変動出来るようにしてもいいかと思います。\nOCIO='/proj/BurninigProj/tools/OCIO/will_be_beautiful.ocio' OCIO_ACTIVE_VIEWS='Rec.709' ローカル変数の代表は、シーケンスとショット番号、フレームレンジとかでしょうか。\nSEQ = 'seq_01' SHOT = 'shot_003' P_START = 1001 P_END = 1032 さて、これらをどうやって全員に行き渡せるかですが、大きい会社ならランチャーがあると思うので、そこで設定してもいいです。\n小さい会社や個人の場合は、パッケージを使うといいでしょう。 https://www.sidefx.com/ja/docs/houdini/ref/plugins.html\nたとえば/proj/BurningProj/tools/houdiniというフォルダの中にプロジェクトのHDAやスクリプトを置き変数を定義するとします。\n/proj/BurningProj └── tools └── houdini └── otls └── packages └── scripts └── toolbar └── maya └── nuke まずメインのパッケージを作ります。これをpackagesフォルダのBurningProj.jsonに保存します。\n{ \"env\" : [ { \"PROJ\" : \"BurninigProj\"}, {\"PROJ_ROOT\": [ {\"houdini_os != 'windows'\" : \"/proj\"}, {\"houdini_os == 'windows'\" : \"Z:/proj\"}, ] }, {\"TEAM_FX\": [ {\"houdini_os != 'windows'\" : \"/team/fx\"}, {\"houdini_os == 'windows'\" : \"T:/fx\"}, ] }, { \"PROJ_TOOLS_HOU\" : \"$PROJ_ROOT/$PROJ/tools/houdini\" }, { \"TEAM_TOOLS_HOU\" : \"$TEAM_FX/tools/houdini/houdini$HOUDINI_MAJOR_RELEASE.$HOUDINI_MINOR_RELEASE\" }, { \"NAGAMOCHI\" : \"$TEAM_TOOLS_HOU/Nagamochi\" }, { \"SIDEFXLABS\" : \"$TEAM_TOOLS_HOU/SideFXLabs\" }, { \"RENDER_RES_X\" : 1920 }, { \"RENDER_RES_Y\" : 960 }, { \"SCALE_FACTOR\" : 10 }, { \"OCIO\" : \"$PROJ_ROOT/$PROJ/tools/OCIO/will_be_beautiful.ocio\" }, { \"OCIO_ACTIVE_VIEWS\" : \"Rec.709\"}, { \"HOUDINI_BUFFEREDSAVE\": [ {\"houdini_os != 'windows'\" : 0}, {\"houdini_os == 'windows'\" : 1}, ] }, { \"HOUDINI_PATH\" : [ \"PROJ_TOOLS_HOU\", \"$NAGAMOCHI/common\", \"$NAGAMOCHI/houdini$HOUDINI_MAJOR_RELEASE.$HOUDINI_MINOR_RELEASE\", \"$SIDEFXLABS\", ] }, ] } つづいて、BurinungProj_User.json(名前はなんでもいい)というファイルを個人の$HOME/houdini18.5/packagesの中に入れてもらいます。このファイルの中身はこうです。1つ前で作ったJsonの置き場を参照してるだけです。\n{ \"package_path\": \"/proj/BurningProj/tools/houdini/packages\" } こうすることによって、環境変数等を変更したい時にメインのひとつだけを編集すれば良いようになります。\n大きい会社でも、融通が聞かないTDがいたり自由度のないランチャーを使用してる場合でも、このパッケージの仕組みを使えば、いちいちチケットを切らずに変数の管理が出来るようになります。\nHOUDINI_PATH 環境変数を設定する時、特に HOUDINI_PATHの読み込み順には気をつけなければいけません。 デフォルトは以下の順で読み込みます。\n$HIP $HOUDINI_USER_PREF_DIR $HFS/houdini $HFS/bin プライグインによってはHOUDINI_PATHの順番を指定してくるものがあります。例えばArnoldは、デフォルトより前に入れてとあります。たしかSOHOの関係だったかな？\n順番の確認はShellでhconfig -apとタイプして確認しましょう。何を言ってるかわからない人は、以下のリンクをどれか見てください。\nhconfig（サルにもわかる)　hconfig (Indyzone) hconfig (BornDigital)\nキャッシュの保存先 FXにとっての悩ましい大きな種の1つは、ストレージを簡単に圧迫させてしまうことです。ここの管理をいかに簡単にし、サイズを出来る限り小さくすることは非常に重要なことです。以下のことを目的として保存先とフォルダ構成を考えいています。\n誰がどれくらい使用しいてるかを把握しやすくする プロジェクト真っ只中でも終わった後でも消しやすくする 間違って上書きしないようにする 可能なかぎり、データのサイズを小さくする まず最初にどこにファイルを保存するかを決めましょう。ここで2つの例をだして考えてみます。\nこういうフォルダ構造があったとします。ユーザの作業フォルダにキャッシュフォルダを作成する場合です。\n/proj/$PROJ/work/$SEQ/$SHOT/$DEPT/$USER\n/proj/BurningProj └── work └── seq_01 └── shot_003 └── fx └── shohei └── caches └── comp └── flipbook └── houdini └── nuke └── render こういう構造なら、Houdini内部では$HIP/../cachesと書くだけでいいです。'..'は一つ上の階層にいくという意味です。なんかプロシージャルっぽいですね。\nただDispatcherを使用している場合は、シーンファイルを別の場所に複製して、そのファイルを使用してサーバで回す場合があります。その際は、サーバでシーンファイルを開いた後に$HIPを上書きしてやる必要があります。\n次の例は作業フォルダではなくキャッシュ専用のフォルダを作る方法です。こんな感じです。\n/proj/$PROJ/caches/$DEPT/$USER/$SEQ/$SHOT/\n/proj/BurningProj └── caches └── fx └── shohei └── seq_01 └── shot_003 └── bob └── seq_05 └── shot_012 これだと、まず各ユーザーがどれだけ使ってるのかを把握するのが簡単になります。ただ、作業フォルダとは別の所にあるので、ファイルブラウザでの移動は面倒になります。また、プロジェクトが終わった時に、/proj/$PROJ/cachesのフォルダを消すだけで一発ですべてのキャッシュが消えるメリットもあります。\nただどちらも、作業者が変わると$USERが変わってしまって他人のキャッシュが読み込めなくなる問題はあります。\nどのフォルダ構造が最適解かというのはないと思います。ここはパイプラインやシステムチームのルールにのっとりつつ、管理のしやすさを考慮しながら考えるのがいいでしょう。\n保存先が決まった場合、ここでは$HIP/../cachesにしたとします。ここより下はどうしたら良いか考えます。Houdiniのデフォルトから考察してみましょう。ファイルキャッシュ系のノードの書き出し先のデフォルトはこうなっています。\n$HIP/geo/$HIPNAME.$OS.$F.bgeo.sc まず保存先$HIP/../cachesに変更します。\n$HIP/../caches/$HIPNAME.$OS.$F.bgeo.sc $HIPNAMEがはいってるとシーファイル名が変わったらキャッシュの読み込みができなくなるので消します。\n$HIP/../caches/$OS.$F.bgeo.sc 書き出しノードが複数あったらcachesというフォルダ下にすべてが保存され管理しにくくなります。なのでノードごとでフォルダを分割します。\n$HIP/../caches/$OS/$OS.$F.bgeo.sc これでも問題があります。たとえばOBJに2つのノードがあって、中に同じ名前のキャッシュノードがあったら、書き出し先が同じ問題が発生してしまいます。( /obj/explosion/cache と /obj/water/cacheは一緒になる）\n回避方法の1つの案としては、親のノード名は異なっているので、フォルダ名に親の名前をいれてバッティングを避けます。（ /obj/explosion/cacheは親の名前がexplosion、キャッシュ名はexplosion__cacheになる）\n$HIP/../caches/`opname(\"..\")`__$OS/`opname(\"..\")`__$OS.$F.bgeo.sc 最後にバージョンでフォルダを分けたいのでバージョンもいれます\n$HIP/../caches/`opname(\"..\")`__$OS/`chs('version')`/`opname(\"..\")`__$OS.`chs('version')`.$F.bgeo.sc こういう結果になりました。\n└── caches └── explosion__cache └── v001 └── explosion__cache.v001.1001.begeo.sc └── v002 └── water__cache └── v001 Pixarの例を見てみましょう。このビデオから彼らのキャッシュノードを見ることが出来ます。\nhttps://vimeo.com/269027205#t=170s\n彼らのパスはこうなっています。\n$FXINSTDIR/caches`opfullpath(\".\")`/$FF.bgeo.sc $FXINSTDIRはどうなっているかはわかりませんが。caches以下がcachesopfullpath(\".\")となっています。opfullpath(\".\")はそのノードのフルパスを返してくれます。/obj/geo1/rop_geometry1みたいな値が返ってきて、フォルダもこんな感じで作られます。\n└── caches └── obj └── geo1 └── cache └── 1001.begeo.sc 1002.begeo.sc └── dopnet1 └── objnet1 └── geo1 └── cache └── 1001.begeo.sc 1002.begeo.sc 私があげた例だとDopの中にObjnetつくって、同じ名前のノードたちを作ってしまったらキャッシュを上書きしてしまう可能性があります。Pixarの場合だと作られるフォルダの深さが一緒ではないので、スクリプト等で管理するのが面倒くさくなるかもしれません。\n基本的にここまで書いてある内容は中間ファイルを想定しています。中間ファイルとは、レンダーや他のソフトに持ってく用のデータではありません。\n正解は無いと思うので、自分たちにあったものを見つけてください。\nキャッシュのオプティマイズ まーもうHoudiniもだいぶユーザー増えてきたし、知ってて当然のことなんで割愛してもいいかと思いましたが、一応さらっと触れときます。\nまず、必要ないアトリビュートは消しましょう。例えば100万ポイントを保存したとします。\nアトリビュートがPしかない場合、10.7MBのキャッシュが出来ました。そこに色を足すと21.6MBです。PもCdもVector3なので、ほぼ2倍のサイズになります。なので必要ないアトリビュートは消しましょう。\nまたAttributeCastというノードを使って、値を32bitから16bitにすればキャッシュサイズが小さくなります。ただこれは、浮動小数点演算の精度を下げていることを留意しないといけません。そして32から16にしたあとに32へ戻しても元の値に戻ることはありません。\nAttrs Size P(Vector3) 10.7MB P(Vector3) rand_val(Float) 14.4MB P(Vector3) Cd(Vector3) 21.4MB P(Vector3) Cd(Vector3, 16bit) 16.1MB 他の案として、これは少し手間ですが、フレームによって変動しない値があるのなら、その値だけ別ファイルに1フレーム保存し、他の動いてる値にあとからAttibuteCopyするのもありです。\n続いてVolumeのオプティマイズです。\nPyro Post-Pprocess Sopというのができて、使ってる人もいるでしょう。ただなぜあれは、VisualizeとOptimizeを一緒のノードにしたのか。分けて欲しかった。\nでは色々比較してみましょう。\nType Size 1. 何もしてない 66.2MB 2. Native VolumeをCompress 29.6MB 3. 1つ上のに対し、Quantization Tolを0.001 27.4MB 4. VDBで16bit 33.8MB 5. VDBの16bit。Densityが無いエリアのVel削除 11.1MB 他にもVelフィールドだけ、Voxelの解像度を落としてやるとかもありますね。\n上の表を見てもらうとわかると思いますが、5番だけ説明をします。 Volumeに対してMotionBlurをかけるとき、DensityやらTemperatureやらがあるとこのみが、絵に影響します。今回の例で言うとDensityしかありません。Densityのないところは、レンダーに関して言えばVelocityがあっても意味ありません。なので、そこのエリアは消してもいいでしょう。VDBCombineを使ってOperationをActive Intersectionにすると、DensityのVoxelがあるところのみ残ります。これだと際が心配なので、VDB ActiveでDensityのVoxelを広げとくと安心です。\nこれは、どのレンダラーにも有効です。なぜならファイルサイズが軽くなるほどファイルの読み込みが速くなるからです。とくに貧弱なWindowsやファイルサーバーを使ってる際は、テストし検討してみてください。\nここでは、全てには言及しませんが、これらを取り入れるときは必ず検証してください。 ファイルサイズが一番軽いのが最適解ではないかもしれません。なのでファイルサイズはもちろんのこと、ファイルの読み書きの時間を計測し、自分たちの環境に最適な方法を見つけてけください 。\nファイルキャッシュノード 書き出し先が決まったら、ファイルキャッシュ用のノードを作ります。\nデフォルトのFileCacheSopではだめです。出力先を設定しなければなりません。もちろんノードを作った時点で、任意のパラメータを自動で変更する仕組みを作ることは可能です。 Houdiniは値を編集したパラメータは太字になるという素晴らしい機能があります。この方法だと作業者は変更していないのに太字になってしまいます。他の作業者の手に渡った時、その値が本当にいじられたがわからなくなるので、避けたほうがよいです。 他にもバージョニングしたかったり、ファイルサイズ削減の機能を入れてもいいでしょう。 カスタムのファイルキャッシュ作成はワークフローの第一歩のHDAとしてオススメ です。なぜならこのノードは必ず誰もが使うことになるノードだからです。\nこのBlog用にファイルキャッシュを作ってみました。\nファイルパスに直接、環境変数やエクスプレッションを入れるのでなく、一度パラメータに逃すのがオススメです。例えば、他の人からシーファイルを受け継いだ時、このノードのキャッシュは読み込めなくなります。なぜなら$USERがフォルダパスに入ってるからです。USERというパラメータを$USERから前の人のユーザーネームを入れれば読むことが出来ます。そしてファイルパスを直接いじると、どの部分をいじったのかが分からなくなるの避けられるようになります。\n独自のファイルキャッシュノードの中にアトリビュートを消したり、VolumeをCompressする機能をつけてもいいでしょう。\nまた、これみたいに何を変更したのかのノートを書き込めるようにしてもいいでしょう。\nhttps://forums.odforce.net/topic/41473-filecache-hda-with-easy-versioning-naming-and-reviewing/\n個人で使ってるのは以下に公開してます。もう少しちゃんと作ってあります。\nhttps://github.com/ShoheiOkazaki/Nagamochi/blob/master/common/otls/SOP__nmFileCache.hda\nレンダリングや他のDCCソフトにデータを返すためにAlembicやVDBを作るノードは別途作りましょう。なぜなら中間ファイルとは使用が異なるからです。必要な機能としては、シーンスケールをもどしたり、Alembicをレンダーする際に必要なアトリビュートを整えたりPathアトリビュートを設定したり、VolumeならCompressとかスケールをしたときの影響を直すとかでしょうか。\nHDA作成ルール HDAを作成するにあったとルールを決めておきましょう。こちらも主に管理目的です。\n一番のオススメはバージョニングしましょう。\n詳しいことは、ここに書いてあるので読んでください。https://www.sidefx.com/ja/docs/houdini/assets/namespaces.html\nなぜ、バージョンを付けたほうが良いかという理由は、\r上書きしてしまうと今までと異なった結果を出力してしまうことを避けるため 。\n他のオススメは、ヘルプに更新履歴を書くことです。 もちろん、パラメータの説明をヘルプにすべて書くのがベストですが、かなりの労力を使うので、\rせめて更新履歴だけを書いてもらうようにしましょう 。\nヘルプについてですが、スクリプトで自動でベースをつくるのがオススメです。自分で書くのは面倒な方は、こういったツールを公開してくれてる人がいますので、使ってみてはいかがでしょうか？ https://vimeo.com/197432788\n一応、私が公開してるツール群にもあります。 シーン作業ルール チームで作業するなら、ある程度のルールを決めたほうがいいです。他の人にシーンを引き継いでもらうときに、わかりやすくしてあげる必要があります。\n経験ある方も多いと思いますが、自分が作った2ヶ月前のシーンファイルをみて、何やってんだこれは？という状態になったことはありませんか。ノードの名前ちゃんとしておけばよかったとか思うでしょう。自分以外の人が見たらきっとなおさらわからないでしょう。\nガチガチにルールを決めると返って作業しづらくなるので、最低限のルールを決めて他の人がみても理解しやすくなるように心がけましょう。\nここでは私自身が取り入れている、いくつかの例をお見せします。\nノードの色 ノードの配置 再現性ある組み方 まずはノードの色。例えばこんなシーンを渡されて「あとはよろしく」と言われてもどこをいじればいいか戸惑うでしょう。 ノードの色にルールを持たせておけば色がついたノードだけを気にかければいいし、色によって意味が違うと判断もしやすくなります 。例えばこんなルールです。\n黄色 : 絵作り等に必要な重要な調整をしてる 緑色 : キーフレームかアニメーションを追加してる 赤色 : プロシージャルではない 紫色 : 他のノードへ出力されている 青色 : Viewportでアトリビュートの値を確認 色がついていないノードは無視していいくらいです。上の添付だと1割も重要なノードは無いことがわかると思います。\nノードの配置にルールをもたせれば、どこに何があるかを把握しやすくなるかもしれません。OBJレベルには、カメラ・ライト・Alembicインポート・作業ノード・レンダー専用のノードといった様々な役割をもったノードが混在してしまいます。個人個人で色んな配置をされるとシーファイルを紐解くのに無駄な時間がかかります。\n枠組みを最初から用意してやって、そこにあったノードを配置するのもありでしょう。\n最後の再現性のある組み方をするですが、どういうことかと言うキャラクタのアニメーションが更新されたり、中間キャッシュが全てなくなっても、一番最後のノードをレンダーすれば、全てを再現できる組み方をすることです。\nこれをやるには/outにすべてのキャッシュノードとレンダーノードが集まっていて、それらが順番に繋がれている必要があります。ディペンデンシーを組むです。Dispacherを使ってる人はやっていることだと思います。\nそして、この組み方をしておけば、アニメーションが更新されたり、別ショットにまるまるシーンをコピーしてもっていったとしても、一番最後のノードのレンダーボタンを押せば、すべてが更新されることが可能です。これぞプロシージャル、これぞHoudiniという使い方です。\nこれを心がけるのは面倒かもですが、Houdiniの基本、プロシージャルに組むということの鍛錬にもってこいです。\nOnCreated.py キャッシュは独自のファイルキャッシュをつくって出力先を気することはなくなりましたが、レンダー系はどうしたらいいでしょうか。これは\rノードが作られた時にパラメータを自動でセットする仕組みを作りましょう 。\nhttps://www.sidefx.com/ja/docs/houdini/hom/locations.html#node_event_files\nHOUDINIPATH/scripts/OnCreated.pyはすべてのノードが作られた時に実行されます。 ただ、これには問題があります。HOUDINI_PATHでいくつかのパッケージを読み込んでいて\rOnCreated.pyが複数あった場合、一番最初（確か)のOnCreateしか実行されません 。複数のパッケージでこれを使いたい場合、運用方法を考える必要があります。\nOnCreateはすべてのノードに対して実行されますが、指定したノードのみを実行するには、HOUDINIPATH/scripts/category/nodename_event.pyにファイルをつくります。例えば、MantraならHOUDINIPATH/scripts/out/ifd_OnCreated.pyにファイルを作ります。\nこんなスクリプトを書くと書き出し先の設定とバージョンのパラメータを追加できます。\nn = kwargs['node'] n.parm('vm_picture').set(\"$HIP/../render/${OS}/${OS}_`chs('version')`.$F4.exr\") parmnum = 8 addVerParm = eval('hou.%sParmTemplate(\"%s\", \"%s\", 1,default_value=([\"%s\"]))' % ('String', 'version', 'Version ', 'v001')) parm = n.parms()[parmnum] parmTmp = parm.parmTemplate() parmGroup = n.parmTemplateGroup() parmIndex = parmGroup.findIndices(parmTmp.name())[0] parmGroup.insertAfter(parmGroup.parmTemplates()[parmIndex],addVerParm) n.setParmTemplateGroup(parmGroup) 456.py 色々ルールを作っても、すべてを遵守してもらうのは大変です。なのでルールや変数が正しいかをチェックする機能を作りましょう。　例えば、現在開いてるシーンの$SEQ, $SHOTの値は正しいか、フレームレンジは正しいかです。タイムレンジはShotgunからひっぱて比較してもいいでしょう。\nまた、カメラが変更されたら作業者は、自分がインポートして使ってるカメラのパスを見て最新かどうかチェックしないといけません。まともな前工程だったらカメラの変更を教えてくれるかもしれませんが、無言で更新することさえあります。めんどくさいですね。なぜ前工程のせいで後工程が・・・以下略\nFXの仕事をしていて、モデルやアニメーションが完全にファイナルの状態、ライティングもFXのために用意されてる状態で作業できることなんてあるでしょうか？夢のような状態ですね。 作業中にカメラが変わったり尺が変更されても対応できるようにしておきましょう。今使ってるカメラ・アセット・タイムレンジが最新なのかを、シーンファイルを開いた時にチェックできるようしてもいいでしょう。\nHoudiniではシーンファイルを開いた時に動くPythonは456.py といいます。 https://www.sidefx.com/ja/docs/houdini/hom/locations.html#startup\nここに置きます。HOUDINIPATH/scripts/456.py\nDispacherを使ってサーバで回すときは、これが動かないような仕組みを入れておいたほうが安全でしょう。\n正直ここはパイプラインがしっかりしていないと使う機会がないかもしれません。とりあえずシーンファイルを開いたときに、シーンの中身をPythonでチェックするすべはあるとだけは覚えておきましょう。\nbeforescenesave.py 456.pyと同様、シーンを保存する時に何かしらのチェック機能が走ってもいいでしょう。\nシーンファイルを開く時は456.py、シーンファイルを保存する直前に動くPythonは789.pyですと言いたいとこですが、そんなものはありません。シーファイルを保存する前に何かをしたい場合は、HOUDINIPATH/scripts/beforescenesave.pyここにファイルを作ります。\n例えば、$SEQ、$SHOTをセットしたいけど、ファイルマネージャー無い場合どうしたらいいでしょうか。こういうフォルダ構造で作業している場合なら、シーンファイルの場所から$SEQ・$SHOTを割り出せます。\n/proj/$PROJ/work/$SEQ/$SHOT/$DEPT/$USER\n/proj/BurningProj └── work └── seq_01 └── shot_003 └── fx └── shohei └── houdini Pythonで書くとこんな感じでしょうか。AliasVariablesの値があるかを確認するためにhou.hscript(\"setenv -s SHOT\")を使ってます。これを使わないとグローバルの環境変数に同じ変数があった場合、そちらの値を参照してしまうので、この方法を取りました。\nimport hou hipfolder = hou.getenv('HIP') dirs = hipfolder.split('/') new_PROJ = dirs[-6] new_SEQ = dirs[-4] new_SHOT = dirs[-3] get_PROJ = hou.hscript(\"setenv -s PROJ\") if 'undefined' in get_PROJ[0]: get_PROJ = None else: get_PROJ = get_PROJ[0].split('\\t= ')[1].split('\\n')[0] 作っておいたほうがいいノード カメラ 前述したように、他DCCからデータを持ってきた時に、シーンスケールを直さないといけません。カメラも同様です。インポートしたカメラノードの上にNullを作ってNullのスケールを0.1とかにしてますか？ま、Houdiniに詳しい人がいる会社なら、そんなことしてませんよね。Volumeの見た目が薄くなってしまいます。解決策は調べればでてくるので説明はしません。Chopでやったほうがいいでしょう。\n私が公開してるツール群のなかにカメラもあるので興味あれば見てください。\nhttps://github.com/ShoheiOkazaki/Nagamochi/blob/master/common/otls/OBJ__nmWorkCam.hd\nおまけ：PDG キャッシュの保存先でストレージの管理をしやすくと言いましたが、お高いファイルサーバーとかだとディスク使用量を解析できるツールがあったりして、誰がどれくらい使ってるかは結構容易にみることができます。ないとこはどうしましょう。\n安心してください。私達には最近PDGという強力なツールを手に入れたので、ディスク使用量も把握が楽になりました\nCSVファイルで保存されるので、これをGoogleSpreadSheat等にコピーし、メンバーに共有しましょう。各ユーザーのキャッシュやシーンファイル・レンダーに使ってる容量の一覧を出すのが簡単になります。便利な時代だ。\nfolderCacheType directory directorySize cache /proj/BurningProj/work/seq_010/shot_009/fx/shohei/cache 84.7 houdini /proj/BurningProj/work/seq_010/shot_009/fx/shohei/houdini 0.1 render /proj/BurningProj/work/seq_010/shot_009/fx/shohei/render 17.2 cache /proj/BurningProj/work/seq_010/shot_011/fx/shohei/cache 18.9 houdini /proj/BurningProj/work/seq_010/shot_011/fx/shohei/houdini 0.2 render /proj/BurningProj/work/seq_010/shot_011/fx/shohei/render 19 cache /proj/BurningProj/work/seq_010/shot_015/fx/shohei/cache 47.7 houdini /proj/BurningProj/work/seq_010/shot_015/fx/shohei/houdini 0.1 render /proj/BurningProj/work/seq_010/shot_015/fx/shohei/render 14.2 cache /proj/BurningProj/work/seq_010/shot_017/fx/shohei/cache 6 houdini /proj/BurningProj/work/seq_010/shot_017/fx/shohei/houdini 0.1 render /proj/BurningProj/work/seq_010/shot_017/fx/shohei/render 10.9 cache /proj/BurningProj/work/seq_040/shot_003/fx/shohei/cache 895.3 houdini /proj/BurningProj/work/seq_040/shot_003/fx/shohei/houdini 18.3 render /proj/BurningProj/work/seq_040/shot_003/fx/shohei/render 347.3 cache /proj/BurningProj/work/seq_070/shot_001/fx/shohei/cache 283.9 houdini /proj/BurningProj/work/seq_070/shot_001/fx/shohei/houdini 0.8 render /proj/BurningProj/work/seq_070/shot_001/fx/shohei/render 124.4 cache /proj/BurningProj/work/seq_070/shot_004/fx/shohei/cache 29.5 houdini /proj/BurningProj/work/seq_070/shot_004/fx/shohei/houdini 0.6 render /proj/BurningProj/work/seq_070/shot_004/fx/shohei/render 0 おまけ：Launcherもどき 最初の方で環境変数を設定するところで、ショットの情報を定義してはどうかと書きました。$PROJ, $SEQ, $SHOTのことです。シーンファイルをオープンセーブする自社ツールがあるなら、これらをセットするのは簡単です。そういうツールがない場合は、Shellからソフトを起動するやり方を紹介します。\nまず作業するPROJ SEQ SHOTを指定してから、ソフトを起動するようにします。\nLinuxでは.bashsrcにaliasを登録します。ここではprojsetとします。\nfunction projset() { export 'PROJ='$1; export 'SEQ='$2; export 'SHOT='$3; export 'HOUDINI_HIP_DEFAULT_NAME='$1'_'$2'_'$3'_FX_ELEMENT_v001.hip'; cd '/proj/'$1'/work/'$2'/'$3'/fx/'$USER/houdini; } alias projset=projset Shellでprojset [PROJ] [SEQ] [SHOT]をタイプすると、そのShotのフォルダに移動します。\nこれでHoudiniを起動すると、＄HIPが任意の場所になり、ファイルのデフォルトの名前もセットされるので、セーブ・オープンともに楽になります。 houdiniは起動したフォルダがHIPになります。HOUDINI_HIP_DEFAULT_NAMEを設定すると、ファイルの名前を変えられます。デフォルトはuntitled.hipですね。\nWindowsの場合はprojset.batというファイルを、aliasを読み込むことが出来るフォルダに保存。\n@echo off set PROJ=%1 set SEQ=%2 set SHOT=%3 set HOUDINI_HIP_DEFAULT_NAME=%1_%2_%3_FX_ELEMENT_v001.hip cd /D W: cd Z:\\proj\\%1\\work\\%2\\%3\\fx\\%USERNAME%\\houdini echo PROJ=%1 SEQ=%2 SHOT=%3 echo HOUDINI_HIP_DEFAULT_NAME=%1_%2_%3_FX_ELEMENT_v001.hip サンプル 長ったらしい文だけど分かりづらいと思うので、サンプルファイルを作りました。サンプルシーンも入ってます。\nDownload\n使い方は、まず解凍したら、フォルダをどこかに置いてください。\n以下2つのjsonファイルの中身のREPLACEという文字を解凍した場所に置き換えてください。\nSampleWorkFlow/packages/BurningProj.json SampleWorkFlow/BurinungProj_User.json\nそしてSampleWorkFlow/BurinungProj_User.jsonを、$HOME/houdini18.5/packages/にコピーしてください。\nおわりに ここまで、紹介したことすべてが必要不可欠で最適解だとは考えていません。10年以上Houdiniメインで仕事をしてきて、私がフルスロットで仕事する上に最低限必要ないくつかを紹介させていただきました。\nHoudini Workflow作るにはPythonは必須です。OdForceやSideFXのフォーラムにたくさんのサンプルがあります。Gitにもあがってるので調べれば大半はでてきます。最初はPythonを書かない簡単なものから始めてもいいでしょう。キャッシュファイルを作るとかでもいいと思います。\nコロナで他の会社の人と交流する機会も減り、情報交換もしづらい世の中になっています。私がいると、こんな感じでやってますが、みなさんはどんなことをしていますか？こんなのが面倒くさいから、こういうのが欲しいみたいな意見でもいいので、ぜひ皆さんからの意見をお待ちしてます。\n","wordCount":"693","inLanguage":"ja","datePublished":"2021-04-29T12:27:07+09:00","dateModified":"2021-04-29T12:27:07+09:00","author":{"@type":"Person","name":"Shohei Okazaki"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ShoheiOkazaki.github.io/FXHACK/posts/2021-04-29/"},"publisher":{"@type":"Organization","name":"FX HACK","logo":{"@type":"ImageObject","url":"https://ShoheiOkazaki.github.io/FXHACK/Thinking_Face_Emoji_large.png"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ShoheiOkazaki.github.io/FXHACK/ accesskey=h title="FX HACK (Alt + H)">FX HACK</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://ShoheiOkazaki.github.io/FXHACK/en/ title=English aria-label=English>🌐English</a></li></ul></div></div><ul id=menu><li><a href=https://ShoheiOkazaki.github.io/FXHACK/posts title=Blog><span>Blog</span></a></li><li><a href=https://ShoheiOkazaki.github.io/FXHACK/search/ title=Search><span>Search</span></a></li><li><a href=https://ShoheiOkazaki.github.io/FXHACK/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ShoheiOkazaki.github.io/FXHACK/Wiki/ title=Wiki><span>Wiki</span></a></li><li><a href=https://ShoheiOkazaki.github.io/FXHACK/fixed/works title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ShoheiOkazaki.github.io/FXHACK/>ホーム</a>&nbsp;»&nbsp;<a href=https://ShoheiOkazaki.github.io/FXHACK/posts/>Posts</a></div><h1 class=post-title>Houdini Workflowについて</h1><div class=post-meta><span title='2021-04-29 12:27:07 +0900 JST'>4月 29, 2021</span>&nbsp;·&nbsp;4 分&nbsp;·&nbsp;Shohei Okazaki&nbsp;|&nbsp;<a href=https://github.com/ShoheiOkazaki/FXHACK/content/posts/2021-04-29/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>いままで何回もHoudini Workflowをつくってきたので、どんなことをやっているか紹介したいと思います。</p><p>小規模な会社にいるからとか個人でやってるから、そんなの必要ないと考える人もいるかもしれませんが、そうは思いません。数人の会社で働いたことがありますが、確実にワークフローが少しでもないと良いパフォーマンスを出すことをできません。</p><p>大規模な会社には専任のTDがいてパイプラインがしっかりあり、色々便利なこともあります。反面、大きくなりすぎた会社ほど、やる気のない人や老害がたまり自由度がなくなり最新の流れにもついていけなくなったり、ワークフローを作るのに大工事したり、パイプラインにも手をいれなければいけないみたいなことも起こってしまいます。小規模だとパイプラインを作るのは難しいですが、ワークフローは自分たちの好きに作りやすいです。自分たちにあったものを構築できれば、小回りがきいて大きな所に負けないワークフローを構築しアドバンテージにすることも出来ます。</p><p>ワークフローは、TDの人やスクリプトをかける人が作るものだと考えるでしょうが、実際に作業するアーティスト主導で構築するべきです。なぜならそのワークフローを使うのは作業者であり、なにが必要なのかを知ってるのは作業者であるアーティストだからです。</p><h2 id=パイプラインワークフロー>パイプライン？　ワークフロー？<a hidden class=anchor aria-hidden=true href=#パイプラインワークフロー>#</a></h2><p>そもそもパイプラインとワークフローの違いはなんなんでしょうか？</p><p><span style=color:gold;font-weight:700;background-color:transparent>パイプラインは、別部署へのデータを送る時、たとえばアセットデータやアニメーションデータやレンダーイメージのパブリッシュなど</span>
です。決められた場所かつ安全な場所にパブリッシュしたり、決まったフォーマットに変換したりします。また、ファイルの命名規則やチェック方法やShotgunとの連携もこちらの役割です。</p><p><span style=color:gold;font-weight:700;background-color:transparent>ワークフローは、アーティストがショット作業をする時に必要なルール・ツール</span>
を用意しておくことです。</p><p>パイプラインはTDが担当しますが、ワークフローは出来る限りそのツールや流れを熟知した人が作るのに携わるのが良いと思います。そしてFXはPythonは書けて当たり前なので、TDにお前らどうせ自分たちで出来るからとか言われ、他の部署を先にやってからと後回しにされがちです。</p><h2 id=目的>目的<a hidden class=anchor aria-hidden=true href=#目的>#</a></h2><p>まずは何のためにワークフローを作るかの目的をしかっり決めましょう。</p><p>私はいつもアーティストが絵作りだけに集中できる環境を作ることを目的にし、できるかぎりのことをするようにしています。</p><p>何を基準にツールやルールを作るかというと、基本この２つをベースに考えます。</p><ol><li><span style=color:gold;font-weight:700;background-color:transparent>ヒューマンエラーをなくす</span></li><li><span style=color:gold;font-weight:700;background-color:transparent>毎回同じことをしたくない</span></li></ol><p>代表格は、キャッシュやレンダーの出力先を毎回入力することです。これはもはや人間のやることではありません。</p><p>チームで新しくワークフローを作る場合は、みんなの意見を聞いて不便なことや要望を洗い出してあげることも大事です。</p><p>チームにジュニアレベルの人やHoudiniに詳しくない人がいるとしたら、色んなレベルの人にもスムーズにいくルールを考える必要があるかもしれません。</p><h2 id=環境変数>環境変数<a hidden class=anchor aria-hidden=true href=#環境変数>#</a></h2><p>まずプロジェクト固有の変数について考えましょう。変数は、
<span style=color:gold;font-weight:700;background-color:transparent>プロジェクト全体に適用されるグローバル変数と、シーケンスやショットごとに値が変わるローカル変数にわけられます。</span></p><p>プロジェクト名やシーケンス名を定義しとくとフォルダの移動やアウトプット先を決めるのが楽になります。ただこの変数はパイプラインとして設定されてることが多いです。小規模な会社や個人では自身で設定してもいいと思います。これらを設定することによってどういうことが出来るかはあとで説明します。</p><pre tabindex=0><code>PROJ = &#39;BurningProj&#39;
</code></pre><p>他のソフトからAlembic等でデータを持ってきた時、シーンスケールを正しくしてあげる必要があります。なぜなら、Houdiniのシミュレーション系ノードのデフォルト値は、1Grid=1mを前提として値が設定されています。これにあわせてやるのが一番良いです。</p><p>大抵の場合はインポートしたものを0.1倍か0.01倍すればいいでしょうが、海外のクライアントからもらったデータはメートルでなくインチで作業してる場合があります。その場合は39.37で割る必要があります。覚えたくないですよね。なので、コレも変数にしておきましょう。</p><pre tabindex=0><code>SCALE_FACTOR = 10
</code></pre><p>他には、レンダーサイズも変数にしてもいいかもしれません。</p><pre tabindex=0><code>RENDER_RES_X=1920
RENDER_RES_Y=960
</code></pre><p>また、WinodwsやLinuxのプラットフォームが混在してる場合、マウントするところを変数にしたとき、少し便利になります。どいうことかというとWindowsは<code>Z:/proj/BuringProj</code>がLinuxでは<code>/proj/BuringProj</code>の場合、<code>$PROJ_ROOT/BuringProj</code>という書き方に統一できます。協力会社によってはクライアントと同じドライブレターが使えないときは、協力会社に$PROJ_ROOTを<code>X:/good_client/A_Inc/proj</code>みたいに設定してもらえれば、フォルダ構造を維持したままシーンファイルを渡せば、別の環境でもシーンを容易に再現できる可能性が高まります。</p><pre tabindex=0><code>PROJ_ROOT = &#39;Z:/proj&#39;
</code></pre><p>日本でもNetflixの仕事が増えてきたせいか、やっとColorMangementが浸透してきましたね。Houdiniも他のソフト同様、OCIOの環境変数を設定してあげる必要があります。ACTIVE_VIEWSはなくてもいいです。VFXではシーケンスやショットごとでLutが違う場合があるので、OCIO_ACTIVE_VIEWSを変動出来るようにしてもいいかと思います。</p><pre tabindex=0><code>OCIO=&#39;/proj/BurninigProj/tools/OCIO/will_be_beautiful.ocio&#39;
OCIO_ACTIVE_VIEWS=&#39;Rec.709&#39;
</code></pre><p>ローカル変数の代表は、シーケンスとショット番号、フレームレンジとかでしょうか。</p><pre tabindex=0><code>SEQ = &#39;seq_01&#39;
SHOT = &#39;shot_003&#39;
P_START = 1001
P_END = 1032
</code></pre><p>さて、これらをどうやって全員に行き渡せるかですが、大きい会社ならランチャーがあると思うので、そこで設定してもいいです。</p><p>小さい会社や個人の場合は、パッケージを使うといいでしょう。 <a href=https://www.sidefx.com/ja/docs/houdini/ref/plugins.html>https://www.sidefx.com/ja/docs/houdini/ref/plugins.html</a></p><p>たとえば<code>/proj/BurningProj/tools/houdini</code>というフォルダの中にプロジェクトのHDAやスクリプトを置き変数を定義するとします。</p><pre tabindex=0><code>
/proj/BurningProj

└── tools

    └── houdini

        └── otls

        └── packages

        └── scripts

        └── toolbar

    └── maya

    └── nuke
</code></pre><p>まずメインのパッケージを作ります。これをpackagesフォルダのBurningProj.jsonに保存します。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>
</span></span><span style=display:flex><span>{   <span style=color:#f92672>&#34;env&#34;</span> : 
</span></span><span style=display:flex><span>    [
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        { <span style=color:#f92672>&#34;PROJ&#34;</span> : <span style=color:#e6db74>&#34;BurninigProj&#34;</span>},
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        {<span style=color:#f92672>&#34;PROJ_ROOT&#34;</span>:
</span></span><span style=display:flex><span>             [
</span></span><span style=display:flex><span>                {<span style=color:#f92672>&#34;houdini_os != &#39;windows&#39;&#34;</span> : <span style=color:#e6db74>&#34;/proj&#34;</span>},
</span></span><span style=display:flex><span>                {<span style=color:#f92672>&#34;houdini_os == &#39;windows&#39;&#34;</span> : <span style=color:#e6db74>&#34;Z:/proj&#34;</span>},
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        {<span style=color:#f92672>&#34;TEAM_FX&#34;</span>:
</span></span><span style=display:flex><span>             [
</span></span><span style=display:flex><span>                {<span style=color:#f92672>&#34;houdini_os != &#39;windows&#39;&#34;</span> : <span style=color:#e6db74>&#34;/team/fx&#34;</span>},
</span></span><span style=display:flex><span>                {<span style=color:#f92672>&#34;houdini_os == &#39;windows&#39;&#34;</span> : <span style=color:#e6db74>&#34;T:/fx&#34;</span>},
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        { <span style=color:#f92672>&#34;PROJ_TOOLS_HOU&#34;</span> : <span style=color:#e6db74>&#34;$PROJ_ROOT/$PROJ/tools/houdini&#34;</span> },
</span></span><span style=display:flex><span>        { <span style=color:#f92672>&#34;TEAM_TOOLS_HOU&#34;</span> : <span style=color:#e6db74>&#34;$TEAM_FX/tools/houdini/houdini$HOUDINI_MAJOR_RELEASE.$HOUDINI_MINOR_RELEASE&#34;</span> },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        { <span style=color:#f92672>&#34;NAGAMOCHI&#34;</span> : <span style=color:#e6db74>&#34;$TEAM_TOOLS_HOU/Nagamochi&#34;</span> },
</span></span><span style=display:flex><span>        { <span style=color:#f92672>&#34;SIDEFXLABS&#34;</span> : <span style=color:#e6db74>&#34;$TEAM_TOOLS_HOU/SideFXLabs&#34;</span> },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        { <span style=color:#f92672>&#34;RENDER_RES_X&#34;</span> : <span style=color:#ae81ff>1920</span> },
</span></span><span style=display:flex><span>        { <span style=color:#f92672>&#34;RENDER_RES_Y&#34;</span> : <span style=color:#ae81ff>960</span> },
</span></span><span style=display:flex><span>        { <span style=color:#f92672>&#34;SCALE_FACTOR&#34;</span> : <span style=color:#ae81ff>10</span> },
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        { <span style=color:#f92672>&#34;OCIO&#34;</span> : <span style=color:#e6db74>&#34;$PROJ_ROOT/$PROJ/tools/OCIO/will_be_beautiful.ocio&#34;</span> },
</span></span><span style=display:flex><span>        { <span style=color:#f92672>&#34;OCIO_ACTIVE_VIEWS&#34;</span> : <span style=color:#e6db74>&#34;Rec.709&#34;</span>},
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        { <span style=color:#f92672>&#34;HOUDINI_BUFFEREDSAVE&#34;</span>:
</span></span><span style=display:flex><span>             [
</span></span><span style=display:flex><span>                {<span style=color:#f92672>&#34;houdini_os != &#39;windows&#39;&#34;</span> : <span style=color:#ae81ff>0</span>},
</span></span><span style=display:flex><span>                {<span style=color:#f92672>&#34;houdini_os == &#39;windows&#39;&#34;</span> : <span style=color:#ae81ff>1</span>},
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        { <span style=color:#f92672>&#34;HOUDINI_PATH&#34;</span> :          
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            [
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;PROJ_TOOLS_HOU&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;$NAGAMOCHI/common&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;$NAGAMOCHI/houdini$HOUDINI_MAJOR_RELEASE.$HOUDINI_MINOR_RELEASE&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;$SIDEFXLABS&#34;</span>,
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>つづいて、BurinungProj_User.json(名前はなんでもいい)というファイルを個人の$HOME/houdini18.5/packagesの中に入れてもらいます。このファイルの中身はこうです。1つ前で作ったJsonの置き場を参照してるだけです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;package_path&#34;</span>: <span style=color:#e6db74>&#34;/proj/BurningProj/tools/houdini/packages&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>こうすることによって、環境変数等を変更したい時にメインのひとつだけを編集すれば良いようになります。</p><p>大きい会社でも、融通が聞かないTDがいたり自由度のないランチャーを使用してる場合でも、このパッケージの仕組みを使えば、いちいちチケットを切らずに変数の管理が出来るようになります。</p><h2 id=houdini_path>HOUDINI_PATH<a hidden class=anchor aria-hidden=true href=#houdini_path>#</a></h2><p>環境変数を設定する時、特に
<span style=color:gold;font-weight:700;background-color:transparent>HOUDINI_PATHの読み込み順には気をつけなければいけません。</span></p><p>デフォルトは以下の順で読み込みます。</p><ol><li>$HIP</li><li>$HOUDINI_USER_PREF_DIR</li><li>$HFS/houdini</li><li>$HFS/bin</li></ol><p>プライグインによってはHOUDINI_PATHの順番を指定してくるものがあります。例えばArnoldは、デフォルトより前に入れてとあります。たしかSOHOの関係だったかな？</p><p>順番の確認はShellで<code>hconfig -ap</code>とタイプして確認しましょう。何を言ってるかわからない人は、以下のリンクをどれか見てください。</p><p><a href=http://ikatnek.blogspot.com/p/houdini-environment-variables.html>hconfig（サルにもわかる)</a>　<a href=https://houdinifx.jp/blog/%E7%92%B0%E5%A2%83%E5%A4%89%E6%95%B0%E3%81%AE%E3%83%91%E3%82%B9%E3%81%AE%E8%A8%98%E8%BF%B0%E3%81%AE%E4%BB%95%E6%96%B9/>hconfig (Indyzone)</a> <a href=https://support.borndigital.co.jp/hc/ja/articles/900001589506-Houdini%E3%81%A7%E8%A8%AD%E5%AE%9A%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E7%92%B0%E5%A2%83%E5%A4%89%E6%95%B0%E3%82%92%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B>hconfig (BornDigital)</a></p><h2 id=キャッシュの保存先>キャッシュの保存先<a hidden class=anchor aria-hidden=true href=#キャッシュの保存先>#</a></h2><p>FXにとっての悩ましい大きな種の1つは、ストレージを簡単に圧迫させてしまうことです。ここの管理をいかに簡単にし、サイズを出来る限り小さくすることは非常に重要なことです。以下のことを目的として保存先とフォルダ構成を考えいています。</p><ol><li><span style=color:gold;font-weight:700;background-color:transparent>誰がどれくらい使用しいてるかを把握しやすくする</span></li><li><span style=color:gold;font-weight:700;background-color:transparent>プロジェクト真っ只中でも終わった後でも消しやすくする</span></li><li><span style=color:gold;font-weight:700;background-color:transparent>間違って上書きしないようにする</span></li><li><span style=color:gold;font-weight:700;background-color:transparent>可能なかぎり、データのサイズを小さくする</span></li></ol><p>まず最初にどこにファイルを保存するかを決めましょう。ここで2つの例をだして考えてみます。</p><p>こういうフォルダ構造があったとします。ユーザの作業フォルダにキャッシュフォルダを作成する場合です。</p><p><code>/proj/$PROJ/work/$SEQ/$SHOT/$DEPT/$USER</code></p><pre tabindex=0><code>/proj/BurningProj

└── work

    └── seq_01

        └── shot_003

                └── fx

                    └── shohei

                        └── caches

                        └── comp

                        └── flipbook

                        └── houdini

                        └── nuke

                        └── render
</code></pre><p>こういう構造なら、Houdini内部では<code>$HIP/../caches</code>と書くだけでいいです。<code>'..'</code>は一つ上の階層にいくという意味です。なんかプロシージャルっぽいですね。</p><p>ただDispatcherを使用している場合は、シーンファイルを別の場所に複製して、そのファイルを使用してサーバで回す場合があります。その際は、サーバでシーンファイルを開いた後に$HIPを上書きしてやる必要があります。</p><p>次の例は作業フォルダではなくキャッシュ専用のフォルダを作る方法です。こんな感じです。</p><p><code>/proj/$PROJ/caches/$DEPT/$USER/$SEQ/$SHOT/</code></p><pre tabindex=0><code>/proj/BurningProj

└── caches

    └── fx

        └── shohei

             └── seq_01

               └── shot_003

        └── bob

             └── seq_05

               └── shot_012
</code></pre><p>これだと、まず各ユーザーがどれだけ使ってるのかを把握するのが簡単になります。ただ、作業フォルダとは別の所にあるので、ファイルブラウザでの移動は面倒になります。また、プロジェクトが終わった時に、<code>/proj/$PROJ/caches</code>のフォルダを消すだけで一発ですべてのキャッシュが消えるメリットもあります。</p><p>ただどちらも、作業者が変わると$USERが変わってしまって他人のキャッシュが読み込めなくなる問題はあります。</p><p>どのフォルダ構造が最適解かというのはないと思います。ここはパイプラインやシステムチームのルールにのっとりつつ、管理のしやすさを考慮しながら考えるのがいいでしょう。</p><p>保存先が決まった場合、ここでは<code>$HIP/../caches</code>にしたとします。ここより下はどうしたら良いか考えます。Houdiniのデフォルトから考察してみましょう。ファイルキャッシュ系のノードの書き出し先のデフォルトはこうなっています。</p><pre tabindex=0><code>$HIP/geo/$HIPNAME.$OS.$F.bgeo.sc
</code></pre><p>まず保存先<code>$HIP/../caches</code>に変更します。</p><pre tabindex=0><code>$HIP/../caches/$HIPNAME.$OS.$F.bgeo.sc
</code></pre><p>$HIPNAMEがはいってるとシーファイル名が変わったらキャッシュの読み込みができなくなるので消します。</p><pre tabindex=0><code>$HIP/../caches/$OS.$F.bgeo.sc
</code></pre><p>書き出しノードが複数あったらcachesというフォルダ下にすべてが保存され管理しにくくなります。なのでノードごとでフォルダを分割します。</p><pre tabindex=0><code>$HIP/../caches/$OS/$OS.$F.bgeo.sc
</code></pre><p>これでも問題があります。たとえばOBJに2つのノードがあって、中に同じ名前のキャッシュノードがあったら、書き出し先が同じ問題が発生してしまいます。( <code>/obj/explosion/cache</code> と <code>/obj/water/cache</code>は一緒になる）</p><p>回避方法の1つの案としては、親のノード名は異なっているので、フォルダ名に親の名前をいれてバッティングを避けます。（ <code>/obj/explosion/cache</code>は親の名前がexplosion、キャッシュ名はexplosion__cacheになる）</p><pre tabindex=0><code>$HIP/../caches/`opname(&#34;..&#34;)`__$OS/`opname(&#34;..&#34;)`__$OS.$F.bgeo.sc
</code></pre><p>最後にバージョンでフォルダを分けたいのでバージョンもいれます</p><pre tabindex=0><code>$HIP/../caches/`opname(&#34;..&#34;)`__$OS/`chs(&#39;version&#39;)`/`opname(&#34;..&#34;)`__$OS.`chs(&#39;version&#39;)`.$F.bgeo.sc
</code></pre><p>こういう結果になりました。</p><pre tabindex=0><code>└── caches

    └── explosion__cache

        └── v001

            └── explosion__cache.v001.1001.begeo.sc

        └── v002

    └── water__cache

        └── v001
</code></pre><p>Pixarの例を見てみましょう。このビデオから彼らのキャッシュノードを見ることが出来ます。</p><p><a href="https://vimeo.com/269027205#t=170s">https://vimeo.com/269027205#t=170s</a></p><p>彼らのパスはこうなっています。</p><pre tabindex=0><code>$FXINSTDIR/caches`opfullpath(&#34;.&#34;)`/$FF.bgeo.sc
</code></pre><p>$FXINSTDIRはどうなっているかはわかりませんが。caches以下がcaches<code>opfullpath(".")</code>となっています。<code>opfullpath(".")</code>はそのノードのフルパスを返してくれます。<code>/obj/geo1/rop_geometry1</code>みたいな値が返ってきて、フォルダもこんな感じで作られます。</p><pre tabindex=0><code>
└── caches

    └── obj

        └── geo1

            └── cache

                └── 1001.begeo.sc

                    1002.begeo.sc

        └── dopnet1

            └── objnet1

                └── geo1

                    └── cache

                            └── 1001.begeo.sc

                                1002.begeo.sc
</code></pre><p>私があげた例だとDopの中にObjnetつくって、同じ名前のノードたちを作ってしまったらキャッシュを上書きしてしまう可能性があります。Pixarの場合だと作られるフォルダの深さが一緒ではないので、スクリプト等で管理するのが面倒くさくなるかもしれません。</p><p>基本的にここまで書いてある内容は中間ファイルを想定しています。中間ファイルとは、レンダーや他のソフトに持ってく用のデータではありません。</p><p>正解は無いと思うので、自分たちにあったものを見つけてください。</p><h2 id=キャッシュのオプティマイズ>キャッシュのオプティマイズ<a hidden class=anchor aria-hidden=true href=#キャッシュのオプティマイズ>#</a></h2><p>まーもうHoudiniもだいぶユーザー増えてきたし、知ってて当然のことなんで割愛してもいいかと思いましたが、一応さらっと触れときます。</p><p>まず、必要ないアトリビュートは消しましょう。例えば100万ポイントを保存したとします。</p><p>アトリビュートがPしかない場合、10.7MBのキャッシュが出来ました。そこに色を足すと21.6MBです。<strong>PもCdもVector3なので、ほぼ2倍のサイズになります</strong>。なので必要ないアトリビュートは消しましょう。</p><p>またAttributeCastというノードを使って、値を32bitから16bitにすればキャッシュサイズが小さくなります。ただこれは、浮動小数点演算の精度を下げていることを留意しないといけません。そして32から16にしたあとに32へ戻しても元の値に戻ることはありません。</p><table><thead><tr><th></th><th>Attrs</th><th>Size</th></tr></thead><tbody><tr><td><img loading=lazy src=img/cache_optimize_001.png alt=img_01></td><td>P(Vector3)</td><td>10.7MB</td></tr><tr><td><img loading=lazy src=img/cache_optimize_002.png alt=img_01></td><td>P(Vector3) rand_val(Float)</td><td>14.4MB</td></tr><tr><td><img loading=lazy src=img/cache_optimize_008.png alt=img_01></td><td>P(Vector3) Cd(Vector3)</td><td>21.4MB</td></tr><tr><td><img loading=lazy src=img/cache_optimize_003.png alt=img_01></td><td>P(Vector3) Cd(Vector3, 16bit)</td><td>16.1MB</td></tr></tbody></table><p>他の案として、これは少し手間ですが、フレームによって変動しない値があるのなら、その値だけ別ファイルに1フレーム保存し、他の動いてる値にあとからAttibuteCopyするのもありです。</p><p>続いてVolumeのオプティマイズです。</p><p>Pyro Post-Pprocess Sopというのができて、使ってる人もいるでしょう。ただなぜあれは、VisualizeとOptimizeを一緒のノードにしたのか。分けて欲しかった。</p><p>では色々比較してみましょう。</p><table><thead><tr><th></th><th>Type</th><th>Size</th></tr></thead><tbody><tr><td><img loading=lazy src=img/cache_optimize_009.png alt=img_01></td><td>1. 何もしてない</td><td>66.2MB</td></tr><tr><td><img loading=lazy src=img/cache_optimize_004.png alt=img_01></td><td>2. Native VolumeをCompress</td><td>29.6MB</td></tr><tr><td><img loading=lazy src=img/cache_optimize_005.png alt=img_01></td><td>3. 1つ上のに対し、Quantization Tolを0.001</td><td>27.4MB</td></tr><tr><td><img loading=lazy src=img/cache_optimize_006.png alt=img_01></td><td>4. VDBで16bit</td><td>33.8MB</td></tr><tr><td><img loading=lazy src=img/cache_optimize_007.png alt=img_01></td><td>5. VDBの16bit。Densityが無いエリアのVel削除</td><td>11.1MB</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>他にもVelフィールドだけ、Voxelの解像度を落としてやるとかもありますね。</p><p>上の表を見てもらうとわかると思いますが、5番だけ説明をします。
Volumeに対してMotionBlurをかけるとき、DensityやらTemperatureやらがあるとこのみが、絵に影響します。今回の例で言うとDensityしかありません。Densityのないところは、レンダーに関して言えばVelocityがあっても意味ありません。なので、そこのエリアは消してもいいでしょう。VDBCombineを使ってOperationをActive Intersectionにすると、DensityのVoxelがあるところのみ残ります。これだと際が心配なので、VDB ActiveでDensityのVoxelを広げとくと安心です。</p><p><img loading=lazy src=img/cache_oprimize_volvel.gif alt=img_01></p><p>これは、どのレンダラーにも有効です。なぜならファイルサイズが軽くなるほどファイルの読み込みが速くなるからです。とくに貧弱なWindowsやファイルサーバーを使ってる際は、テストし検討してみてください。</p><p>ここでは、全てには言及しませんが、これらを取り入れるときは必ず検証してください。
<span style=color:gold;font-weight:700;background-color:transparent>ファイルサイズが一番軽いのが最適解ではないかもしれません。なのでファイルサイズはもちろんのこと、ファイルの読み書きの時間を計測し、自分たちの環境に最適な方法を見つけてけください</span>
。</p><h2 id=ファイルキャッシュノード>ファイルキャッシュノード<a hidden class=anchor aria-hidden=true href=#ファイルキャッシュノード>#</a></h2><p>書き出し先が決まったら、ファイルキャッシュ用のノードを作ります。</p><p>デフォルトのFileCacheSopではだめです。出力先を設定しなければなりません。もちろんノードを作った時点で、任意のパラメータを自動で変更する仕組みを作ることは可能です。
Houdiniは値を編集したパラメータは太字になるという素晴らしい機能があります。この方法だと作業者は変更していないのに太字になってしまいます。他の作業者の手に渡った時、その値が本当にいじられたがわからなくなるので、避けたほうがよいです。
他にもバージョニングしたかったり、ファイルサイズ削減の機能を入れてもいいでしょう。
<span style=color:gold;font-weight:700;background-color:transparent>カスタムのファイルキャッシュ作成はワークフローの第一歩のHDAとしてオススメ</span>
です。なぜならこのノードは必ず誰もが使うことになるノードだからです。</p><p>このBlog用にファイルキャッシュを作ってみました。</p><p><img loading=lazy src=img/filecahe_001.png alt=img_01></p><p>ファイルパスに直接、環境変数やエクスプレッションを入れるのでなく、一度パラメータに逃すのがオススメです。例えば、他の人からシーファイルを受け継いだ時、このノードのキャッシュは読み込めなくなります。なぜなら$USERがフォルダパスに入ってるからです。USERというパラメータを$USERから前の人のユーザーネームを入れれば読むことが出来ます。そしてファイルパスを直接いじると、どの部分をいじったのかが分からなくなるの避けられるようになります。</p><p>独自のファイルキャッシュノードの中にアトリビュートを消したり、VolumeをCompressする機能をつけてもいいでしょう。</p><p>また、これみたいに何を変更したのかのノートを書き込めるようにしてもいいでしょう。</p><p><a href=https://forums.odforce.net/topic/41473-filecache-hda-with-easy-versioning-naming-and-reviewing/>https://forums.odforce.net/topic/41473-filecache-hda-with-easy-versioning-naming-and-reviewing/</a></p><p>個人で使ってるのは以下に公開してます。もう少しちゃんと作ってあります。</p><p><a href=https://github.com/ShoheiOkazaki/Nagamochi/blob/master/common/otls/SOP__nmFileCache.hda>https://github.com/ShoheiOkazaki/Nagamochi/blob/master/common/otls/SOP__nmFileCache.hda</a></p><p>レンダリングや他のDCCソフトにデータを返すためにAlembicやVDBを作るノードは別途作りましょう。なぜなら中間ファイルとは使用が異なるからです。必要な機能としては、シーンスケールをもどしたり、Alembicをレンダーする際に必要なアトリビュートを整えたりPathアトリビュートを設定したり、VolumeならCompressとかスケールをしたときの影響を直すとかでしょうか。</p><h2 id=hda作成ルール>HDA作成ルール<a hidden class=anchor aria-hidden=true href=#hda作成ルール>#</a></h2><p>HDAを作成するにあったとルールを決めておきましょう。こちらも主に管理目的です。</p><p>一番のオススメはバージョニングしましょう。</p><p><img loading=lazy src=img/Hda_Rule_001.png alt=img_01></p><p>詳しいことは、ここに書いてあるので読んでください。https://www.sidefx.com/ja/docs/houdini/assets/namespaces.html</p><p>なぜ、バージョンを付けたほうが良いかという理由は、
<span style=color:gold;font-weight:700;background-color:transparent>上書きしてしまうと今までと異なった結果を出力してしまうことを避けるため</span>
。</p><p>他のオススメは、ヘルプに更新履歴を書くことです。
<img loading=lazy src=img/Hda_Rule_002.png alt=img_01></p><p>もちろん、パラメータの説明をヘルプにすべて書くのがベストですが、かなりの労力を使うので、
<span style=color:gold;font-weight:700;background-color:transparent>せめて更新履歴だけを書いてもらうようにしましょう</span>
。</p><p>ヘルプについてですが、スクリプトで自動でベースをつくるのがオススメです。自分で書くのは面倒な方は、こういったツールを公開してくれてる人がいますので、使ってみてはいかがでしょうか？
<a href=https://vimeo.com/197432788>https://vimeo.com/197432788</a></p><p>一応、私が<a href=https://github.com/ShoheiOkazaki/Nagamochi>公開してるツール群</a>にもあります。
<img loading=lazy src=img/Hda_Rule_003.png alt=img_01></p><h2 id=シーン作業ルール>シーン作業ルール<a hidden class=anchor aria-hidden=true href=#シーン作業ルール>#</a></h2><p>チームで作業するなら、ある程度のルールを決めたほうがいいです。他の人にシーンを引き継いでもらうときに、わかりやすくしてあげる必要があります。</p><p>経験ある方も多いと思いますが、自分が作った2ヶ月前のシーンファイルをみて、何やってんだこれは？という状態になったことはありませんか。ノードの名前ちゃんとしておけばよかったとか思うでしょう。自分以外の人が見たらきっとなおさらわからないでしょう。</p><p>ガチガチにルールを決めると返って作業しづらくなるので、最低限のルールを決めて他の人がみても理解しやすくなるように心がけましょう。</p><p>ここでは私自身が取り入れている、いくつかの例をお見せします。</p><ol><li>ノードの色</li><li>ノードの配置</li><li>再現性ある組み方</li></ol><p>まずはノードの色。例えばこんなシーンを渡されて「あとはよろしく」と言われてもどこをいじればいいか戸惑うでしょう。
<img loading=lazy src=img/scene_rule_001.png alt=img_01></p><p><span style=color:gold;font-weight:700;background-color:transparent>ノードの色にルールを持たせておけば色がついたノードだけを気にかければいいし、色によって意味が違うと判断もしやすくなります</span>
。例えばこんなルールです。</p><ul><li>黄色 : 絵作り等に必要な重要な調整をしてる</li><li>緑色 : キーフレームかアニメーションを追加してる</li><li>赤色 : プロシージャルではない</li><li>紫色 : 他のノードへ出力されている</li><li>青色 : Viewportでアトリビュートの値を確認</li></ul><p>色がついていないノードは無視していいくらいです。上の添付だと1割も重要なノードは無いことがわかると思います。</p><p>ノードの配置にルールをもたせれば、どこに何があるかを把握しやすくなるかもしれません。OBJレベルには、カメラ・ライト・Alembicインポート・作業ノード・レンダー専用のノードといった様々な役割をもったノードが混在してしまいます。個人個人で色んな配置をされるとシーファイルを紐解くのに無駄な時間がかかります。</p><p><img loading=lazy src=img/scene_rule_002.png alt=img_01></p><p>枠組みを最初から用意してやって、そこにあったノードを配置するのもありでしょう。</p><p>最後の再現性のある組み方をするですが、どういうことかと言うキャラクタのアニメーションが更新されたり、中間キャッシュが全てなくなっても、一番最後のノードをレンダーすれば、全てを再現できる組み方をすることです。</p><p>これをやるには<code>/out</code>にすべてのキャッシュノードとレンダーノードが集まっていて、それらが順番に繋がれている必要があります。ディペンデンシーを組むです。Dispacherを使ってる人はやっていることだと思います。</p><p><img loading=lazy src=img/scene_rule_003.png alt=img_01></p><p>そして、この組み方をしておけば、アニメーションが更新されたり、別ショットにまるまるシーンをコピーしてもっていったとしても、一番最後のノードのレンダーボタンを押せば、すべてが更新されることが可能です。これぞプロシージャル、これぞHoudiniという使い方です。</p><p>これを心がけるのは面倒かもですが、Houdiniの基本、プロシージャルに組むということの鍛錬にもってこいです。</p><h2 id=oncreatedpy>OnCreated.py<a hidden class=anchor aria-hidden=true href=#oncreatedpy>#</a></h2><p>キャッシュは独自のファイルキャッシュをつくって出力先を気することはなくなりましたが、レンダー系はどうしたらいいでしょうか。これは
<span style=color:gold;font-weight:700;background-color:transparent>ノードが作られた時にパラメータを自動でセットする仕組みを作りましょう</span>
。</p><p><a href=https://www.sidefx.com/ja/docs/houdini/hom/locations.html#node_event_files>https://www.sidefx.com/ja/docs/houdini/hom/locations.html#node_event_files</a></p><p><code>HOUDINIPATH/scripts/OnCreated.py</code>はすべてのノードが作られた時に実行されます。
ただ、これには問題があります。HOUDINI_PATHでいくつかのパッケージを読み込んでいて
<span style=color:gold;font-weight:700;background-color:transparent>OnCreated.pyが複数あった場合、一番最初（確か)のOnCreateしか実行されません</span>
。複数のパッケージでこれを使いたい場合、運用方法を考える必要があります。</p><p>OnCreateはすべてのノードに対して実行されますが、指定したノードのみを実行するには、<code>HOUDINIPATH/scripts/category/nodename_event.py</code>にファイルをつくります。例えば、Mantraなら<code>HOUDINIPATH/scripts/out/ifd_OnCreated.py</code>にファイルを作ります。</p><p>こんなスクリプトを書くと書き出し先の設定とバージョンのパラメータを追加できます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>n <span style=color:#f92672>=</span> kwargs[<span style=color:#e6db74>&#39;node&#39;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>n<span style=color:#f92672>.</span>parm(<span style=color:#e6db74>&#39;vm_picture&#39;</span>)<span style=color:#f92672>.</span>set(<span style=color:#e6db74>&#34;$HIP/../render/$</span><span style=color:#e6db74>{OS}</span><span style=color:#e6db74>/$</span><span style=color:#e6db74>{OS}</span><span style=color:#e6db74>_`chs(&#39;version&#39;)`.$F4.exr&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>parmnum <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span> 
</span></span><span style=display:flex><span>addVerParm <span style=color:#f92672>=</span> eval(<span style=color:#e6db74>&#39;hou.</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>ParmTemplate(&#34;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;, &#34;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;, 1,default_value=([&#34;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;]))&#39;</span> <span style=color:#f92672>%</span> (<span style=color:#e6db74>&#39;String&#39;</span>, <span style=color:#e6db74>&#39;version&#39;</span>, <span style=color:#e6db74>&#39;Version &#39;</span>, <span style=color:#e6db74>&#39;v001&#39;</span>))
</span></span><span style=display:flex><span>parm <span style=color:#f92672>=</span> n<span style=color:#f92672>.</span>parms()[parmnum]
</span></span><span style=display:flex><span>parmTmp <span style=color:#f92672>=</span> parm<span style=color:#f92672>.</span>parmTemplate()
</span></span><span style=display:flex><span>parmGroup <span style=color:#f92672>=</span> n<span style=color:#f92672>.</span>parmTemplateGroup()
</span></span><span style=display:flex><span>parmIndex <span style=color:#f92672>=</span> parmGroup<span style=color:#f92672>.</span>findIndices(parmTmp<span style=color:#f92672>.</span>name())[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>parmGroup<span style=color:#f92672>.</span>insertAfter(parmGroup<span style=color:#f92672>.</span>parmTemplates()[parmIndex],addVerParm)
</span></span><span style=display:flex><span>n<span style=color:#f92672>.</span>setParmTemplateGroup(parmGroup)
</span></span></code></pre></div><p><img loading=lazy src=img/OnCreated_001.png alt=img_01></p><h2 id=456py>456.py<a hidden class=anchor aria-hidden=true href=#456py>#</a></h2><p>色々ルールを作っても、すべてを遵守してもらうのは大変です。なのでルールや変数が正しいかをチェックする機能を作りましょう。　</p><p>例えば、現在開いてるシーンの$SEQ, $SHOTの値は正しいか、フレームレンジは正しいかです。タイムレンジはShotgunからひっぱて比較してもいいでしょう。</p><p>また、カメラが変更されたら作業者は、自分がインポートして使ってるカメラのパスを見て最新かどうかチェックしないといけません。まともな前工程だったらカメラの変更を教えてくれるかもしれませんが、無言で更新することさえあります。めんどくさいですね。なぜ前工程のせいで後工程が・・・以下略</p><p>FXの仕事をしていて、モデルやアニメーションが完全にファイナルの状態、ライティングもFXのために用意されてる状態で作業できることなんてあるでしょうか？夢のような状態ですね。
作業中にカメラが変わったり尺が変更されても対応できるようにしておきましょう。今使ってるカメラ・アセット・タイムレンジが最新なのかを、シーンファイルを開いた時にチェックできるようしてもいいでしょう。</p><p><span style=color:gold;font-weight:700;background-color:transparent>Houdiniではシーンファイルを開いた時に動くPythonは456.py</span>
といいます。 <a href=https://www.sidefx.com/ja/docs/houdini/hom/locations.html#startup>https://www.sidefx.com/ja/docs/houdini/hom/locations.html#startup</a></p><p>ここに置きます。<code>HOUDINIPATH/scripts/456.py</code></p><p>Dispacherを使ってサーバで回すときは、これが動かないような仕組みを入れておいたほうが安全でしょう。</p><p>正直ここはパイプラインがしっかりしていないと使う機会がないかもしれません。とりあえずシーンファイルを開いたときに、シーンの中身をPythonでチェックするすべはあるとだけは覚えておきましょう。</p><h2 id=beforescenesavepy>beforescenesave.py<a hidden class=anchor aria-hidden=true href=#beforescenesavepy>#</a></h2><p>456.pyと同様、シーンを保存する時に何かしらのチェック機能が走ってもいいでしょう。</p><p>シーンファイルを開く時は456.py、シーンファイルを保存する直前に動くPythonは789.pyですと言いたいとこですが、そんなものはありません。シーファイルを保存する前に何かをしたい場合は、<code>HOUDINIPATH/scripts/beforescenesave.py</code>ここにファイルを作ります。</p><p>例えば、$SEQ、$SHOTをセットしたいけど、ファイルマネージャー無い場合どうしたらいいでしょうか。こういうフォルダ構造で作業している場合なら、シーンファイルの場所から$SEQ・$SHOTを割り出せます。</p><p><code>/proj/$PROJ/work/$SEQ/$SHOT/$DEPT/$USER</code></p><pre tabindex=0><code>/proj/BurningProj

└── work

    └── seq_01

        └── shot_003

            └── fx

                └── shohei

                    └── houdini
</code></pre><p>Pythonで書くとこんな感じでしょうか。AliasVariablesの値があるかを確認するために<code>hou.hscript("setenv -s SHOT")</code>を使ってます。これを使わないとグローバルの環境変数に同じ変数があった場合、そちらの値を参照してしまうので、この方法を取りました。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#f92672>import</span> hou
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>hipfolder <span style=color:#f92672>=</span> hou<span style=color:#f92672>.</span>getenv(<span style=color:#e6db74>&#39;HIP&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dirs <span style=color:#f92672>=</span> hipfolder<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;/&#39;</span>)
</span></span><span style=display:flex><span>new_PROJ <span style=color:#f92672>=</span> dirs[<span style=color:#f92672>-</span><span style=color:#ae81ff>6</span>]
</span></span><span style=display:flex><span>new_SEQ  <span style=color:#f92672>=</span> dirs[<span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>]
</span></span><span style=display:flex><span>new_SHOT <span style=color:#f92672>=</span> dirs[<span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>get_PROJ <span style=color:#f92672>=</span> hou<span style=color:#f92672>.</span>hscript(<span style=color:#e6db74>&#34;setenv -s PROJ&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;undefined&#39;</span> <span style=color:#f92672>in</span> get_PROJ[<span style=color:#ae81ff>0</span>]:
</span></span><span style=display:flex><span>    get_PROJ <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>    get_PROJ <span style=color:#f92672>=</span> get_PROJ[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>= &#39;</span>)[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>split(<span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span>)[<span style=color:#ae81ff>0</span>]
</span></span></code></pre></div><h2 id=作っておいたほうがいいノード>作っておいたほうがいいノード<a hidden class=anchor aria-hidden=true href=#作っておいたほうがいいノード>#</a></h2><h4 id=カメラ>カメラ<a hidden class=anchor aria-hidden=true href=#カメラ>#</a></h4><p>前述したように、他DCCからデータを持ってきた時に、シーンスケールを直さないといけません。カメラも同様です。インポートしたカメラノードの上にNullを作ってNullのスケールを0.1とかにしてますか？ま、Houdiniに詳しい人がいる会社なら、そんなことしてませんよね。Volumeの見た目が薄くなってしまいます。解決策は調べればでてくるので説明はしません。Chopでやったほうがいいでしょう。</p><p>私が公開してるツール群のなかにカメラもあるので興味あれば見てください。</p><p><a href=https://github.com/ShoheiOkazaki/Nagamochi/blob/master/common/otls/OBJ__nmWorkCam.hd>https://github.com/ShoheiOkazaki/Nagamochi/blob/master/common/otls/OBJ__nmWorkCam.hd</a></p><p><img loading=lazy src=img/recommend_node_cam.png alt=img_01></p><h2 id=おまけpdg>おまけ：PDG<a hidden class=anchor aria-hidden=true href=#おまけpdg>#</a></h2><p>キャッシュの保存先でストレージの管理をしやすくと言いましたが、お高いファイルサーバーとかだとディスク使用量を解析できるツールがあったりして、誰がどれくらい使ってるかは結構容易にみることができます。ないとこはどうしましょう。</p><p>安心してください。私達には最近PDGという強力なツールを手に入れたので、ディスク使用量も把握が楽になりました</p><p><img loading=lazy src=img/PDG_001.png alt=img_01></p><p>CSVファイルで保存されるので、これをGoogleSpreadSheat等にコピーし、メンバーに共有しましょう。各ユーザーのキャッシュやシーンファイル・レンダーに使ってる容量の一覧を出すのが簡単になります。便利な時代だ。</p><table><thead><tr><th style=text-align:left>folderCacheType</th><th style=text-align:left>directory</th><th style=text-align:left>directorySize</th></tr></thead><tbody><tr><td style=text-align:left>cache</td><td style=text-align:left>/proj/BurningProj/work/seq_010/shot_009/fx/shohei/cache</td><td style=text-align:left>84.7</td></tr><tr><td style=text-align:left>houdini</td><td style=text-align:left>/proj/BurningProj/work/seq_010/shot_009/fx/shohei/houdini</td><td style=text-align:left>0.1</td></tr><tr><td style=text-align:left>render</td><td style=text-align:left>/proj/BurningProj/work/seq_010/shot_009/fx/shohei/render</td><td style=text-align:left>17.2</td></tr><tr><td style=text-align:left>cache</td><td style=text-align:left>/proj/BurningProj/work/seq_010/shot_011/fx/shohei/cache</td><td style=text-align:left>18.9</td></tr><tr><td style=text-align:left>houdini</td><td style=text-align:left>/proj/BurningProj/work/seq_010/shot_011/fx/shohei/houdini</td><td style=text-align:left>0.2</td></tr><tr><td style=text-align:left>render</td><td style=text-align:left>/proj/BurningProj/work/seq_010/shot_011/fx/shohei/render</td><td style=text-align:left>19</td></tr><tr><td style=text-align:left>cache</td><td style=text-align:left>/proj/BurningProj/work/seq_010/shot_015/fx/shohei/cache</td><td style=text-align:left>47.7</td></tr><tr><td style=text-align:left>houdini</td><td style=text-align:left>/proj/BurningProj/work/seq_010/shot_015/fx/shohei/houdini</td><td style=text-align:left>0.1</td></tr><tr><td style=text-align:left>render</td><td style=text-align:left>/proj/BurningProj/work/seq_010/shot_015/fx/shohei/render</td><td style=text-align:left>14.2</td></tr><tr><td style=text-align:left>cache</td><td style=text-align:left>/proj/BurningProj/work/seq_010/shot_017/fx/shohei/cache</td><td style=text-align:left>6</td></tr><tr><td style=text-align:left>houdini</td><td style=text-align:left>/proj/BurningProj/work/seq_010/shot_017/fx/shohei/houdini</td><td style=text-align:left>0.1</td></tr><tr><td style=text-align:left>render</td><td style=text-align:left>/proj/BurningProj/work/seq_010/shot_017/fx/shohei/render</td><td style=text-align:left>10.9</td></tr><tr><td style=text-align:left>cache</td><td style=text-align:left>/proj/BurningProj/work/seq_040/shot_003/fx/shohei/cache</td><td style=text-align:left>895.3</td></tr><tr><td style=text-align:left>houdini</td><td style=text-align:left>/proj/BurningProj/work/seq_040/shot_003/fx/shohei/houdini</td><td style=text-align:left>18.3</td></tr><tr><td style=text-align:left>render</td><td style=text-align:left>/proj/BurningProj/work/seq_040/shot_003/fx/shohei/render</td><td style=text-align:left>347.3</td></tr><tr><td style=text-align:left>cache</td><td style=text-align:left>/proj/BurningProj/work/seq_070/shot_001/fx/shohei/cache</td><td style=text-align:left>283.9</td></tr><tr><td style=text-align:left>houdini</td><td style=text-align:left>/proj/BurningProj/work/seq_070/shot_001/fx/shohei/houdini</td><td style=text-align:left>0.8</td></tr><tr><td style=text-align:left>render</td><td style=text-align:left>/proj/BurningProj/work/seq_070/shot_001/fx/shohei/render</td><td style=text-align:left>124.4</td></tr><tr><td style=text-align:left>cache</td><td style=text-align:left>/proj/BurningProj/work/seq_070/shot_004/fx/shohei/cache</td><td style=text-align:left>29.5</td></tr><tr><td style=text-align:left>houdini</td><td style=text-align:left>/proj/BurningProj/work/seq_070/shot_004/fx/shohei/houdini</td><td style=text-align:left>0.6</td></tr><tr><td style=text-align:left>render</td><td style=text-align:left>/proj/BurningProj/work/seq_070/shot_004/fx/shohei/render</td><td style=text-align:left>0</td></tr></tbody></table><h2 id=おまけlauncherもどき>おまけ：Launcherもどき<a hidden class=anchor aria-hidden=true href=#おまけlauncherもどき>#</a></h2><p>最初の方で環境変数を設定するところで、ショットの情報を定義してはどうかと書きました。$PROJ, $SEQ, $SHOTのことです。シーンファイルをオープンセーブする自社ツールがあるなら、これらをセットするのは簡単です。そういうツールがない場合は、Shellからソフトを起動するやり方を紹介します。</p><p>まず作業するPROJ SEQ SHOTを指定してから、ソフトを起動するようにします。</p><p>Linuxでは.bashsrcにaliasを登録します。ここではprojsetとします。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#66d9ef>function</span> projset<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    export <span style=color:#e6db74>&#39;PROJ=&#39;</span>$1;
</span></span><span style=display:flex><span>    export <span style=color:#e6db74>&#39;SEQ=&#39;</span>$2;
</span></span><span style=display:flex><span>    export <span style=color:#e6db74>&#39;SHOT=&#39;</span>$3;
</span></span><span style=display:flex><span>    export <span style=color:#e6db74>&#39;HOUDINI_HIP_DEFAULT_NAME=&#39;</span>$1<span style=color:#e6db74>&#39;_&#39;</span>$2<span style=color:#e6db74>&#39;_&#39;</span>$3<span style=color:#e6db74>&#39;_FX_ELEMENT_v001.hip&#39;</span>;
</span></span><span style=display:flex><span>    cd <span style=color:#e6db74>&#39;/proj/&#39;</span>$1<span style=color:#e6db74>&#39;/work/&#39;</span>$2<span style=color:#e6db74>&#39;/&#39;</span>$3<span style=color:#e6db74>&#39;/fx/&#39;</span>$USER/houdini;
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>alias projset<span style=color:#f92672>=</span>projset
</span></span></code></pre></div><p>Shellでprojset [PROJ] [SEQ] [SHOT]をタイプすると、そのShotのフォルダに移動します。</p><p><img loading=lazy src=img/launcher_001.png alt=img_01></p><p>これでHoudiniを起動すると、＄HIPが任意の場所になり、ファイルのデフォルトの名前もセットされるので、セーブ・オープンともに楽になります。
houdiniは起動したフォルダがHIPになります。HOUDINI_HIP_DEFAULT_NAMEを設定すると、ファイルの名前を変えられます。デフォルトはuntitled.hipですね。</p><p><img loading=lazy src=img/launcher_002.png alt=img_01></p><p>Windowsの場合はprojset.batというファイルを、aliasを読み込むことが出来るフォルダに保存。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>@echo off
</span></span><span style=display:flex><span>set PROJ<span style=color:#f92672>=</span>%1
</span></span><span style=display:flex><span>set SEQ<span style=color:#f92672>=</span>%2
</span></span><span style=display:flex><span>set SHOT<span style=color:#f92672>=</span>%3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>set HOUDINI_HIP_DEFAULT_NAME<span style=color:#f92672>=</span>%1_%2_%3_FX_ELEMENT_v001.hip
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cd /D W:
</span></span><span style=display:flex><span>cd Z:<span style=color:#ae81ff>\p</span>roj<span style=color:#ae81ff>\%</span>1<span style=color:#ae81ff>\w</span>ork<span style=color:#ae81ff>\%</span>2<span style=color:#ae81ff>\%</span>3<span style=color:#ae81ff>\f</span>x<span style=color:#ae81ff>\%</span>USERNAME%<span style=color:#ae81ff>\h</span>oudini
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>echo PROJ<span style=color:#f92672>=</span>%1 SEQ<span style=color:#f92672>=</span>%2 SHOT<span style=color:#f92672>=</span>%3
</span></span><span style=display:flex><span>echo HOUDINI_HIP_DEFAULT_NAME<span style=color:#f92672>=</span>%1_%2_%3_FX_ELEMENT_v001.hip
</span></span></code></pre></div><h2 id=サンプル>サンプル<a hidden class=anchor aria-hidden=true href=#サンプル>#</a></h2><p>長ったらしい文だけど分かりづらいと思うので、サンプルファイルを作りました。サンプルシーンも入ってます。</p><p><a href=SampleWorkFlow.zip>Download</a></p><p>使い方は、まず解凍したら、フォルダをどこかに置いてください。</p><p>以下2つのjsonファイルの中身のREPLACEという文字を解凍した場所に置き換えてください。</p><p><code>SampleWorkFlow/packages/BurningProj.json</code>
<code>SampleWorkFlow/BurinungProj_User.json</code></p><p>そして<code>SampleWorkFlow/BurinungProj_User.json</code>を、<code>$HOME/houdini18.5/packages/</code>にコピーしてください。</p><h2 id=おわりに>おわりに<a hidden class=anchor aria-hidden=true href=#おわりに>#</a></h2><p>ここまで、紹介したことすべてが必要不可欠で最適解だとは考えていません。10年以上Houdiniメインで仕事をしてきて、私がフルスロットで仕事する上に最低限必要ないくつかを紹介させていただきました。</p><p>Houdini Workflow作るにはPythonは必須です。OdForceやSideFXのフォーラムにたくさんのサンプルがあります。Gitにもあがってるので調べれば大半はでてきます。最初はPythonを書かない簡単なものから始めてもいいでしょう。キャッシュファイルを作るとかでもいいと思います。</p><p>コロナで他の会社の人と交流する機会も減り、情報交換もしづらい世の中になっています。私がいると、こんな感じでやってますが、みなさんはどんなことをしていますか？こんなのが面倒くさいから、こういうのが欲しいみたいな意見でもいいので、ぜひ皆さんからの意見をお待ちしてます。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ShoheiOkazaki.github.io/FXHACK/tags/houdini/>Houdini</a></li><li><a href=https://ShoheiOkazaki.github.io/FXHACK/tags/python/>Python</a></li><li><a href=https://ShoheiOkazaki.github.io/FXHACK/tags/workflow/>Workflow</a></li></ul><nav class=paginav><a class=next href=https://ShoheiOkazaki.github.io/FXHACK/posts/2019-02-12/><span class=title>次のページ »</span><br><span>FX的　Height Fieldの使い方</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Houdini Workflowについて on twitter" href="https://twitter.com/intent/tweet/?text=Houdini%20Workflow%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&url=https%3a%2f%2fShoheiOkazaki.github.io%2fFXHACK%2fposts%2f2021-04-29%2f&hashtags=Houdini%2cPython%2cWorkflow"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Houdini Workflowについて on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fShoheiOkazaki.github.io%2fFXHACK%2fposts%2f2021-04-29%2f&title=Houdini%20Workflow%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&summary=Houdini%20Workflow%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&source=https%3a%2f%2fShoheiOkazaki.github.io%2fFXHACK%2fposts%2f2021-04-29%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Houdini Workflowについて on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fShoheiOkazaki.github.io%2fFXHACK%2fposts%2f2021-04-29%2f&title=Houdini%20Workflow%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Houdini Workflowについて on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fShoheiOkazaki.github.io%2fFXHACK%2fposts%2f2021-04-29%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Houdini Workflowについて on whatsapp" href="https://api.whatsapp.com/send?text=Houdini%20Workflow%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6%20-%20https%3a%2f%2fShoheiOkazaki.github.io%2fFXHACK%2fposts%2f2021-04-29%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Houdini Workflowについて on telegram" href="https://telegram.me/share/url?text=Houdini%20Workflow%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6&url=https%3a%2f%2fShoheiOkazaki.github.io%2fFXHACK%2fposts%2f2021-04-29%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://ShoheiOkazaki.github.io/FXHACK/>FX HACK</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="コピー";function s(){t.innerHTML="コピーされました!",setTimeout(()=>{t.innerHTML="コピー"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>